BP_VERSION = "v0.2.4-beta";
BP_SUPPORTED_AUDIO_FORMATS = ".wav" ".aif" ".aiff" ".mp3";
BP_DATABASE_OUTPUT = null;
BP_TREE_NORM = null;
BP_REF_LABEL_UTILS = "utilities";
BP_REF_LABEL_PROCESS = "audio processing";
BP_REF_LABEL_GEN = "audio generation";
BP_REF_LABEL_ANALYSIS = "audio analysis";
BP_REF = (for $i in BP_REF_LABEL_UTILS BP_REF_LABEL_PROCESS BP_REF_LABEL_GEN BP_REF_LABEL_ANALYSIS collect [ $i ]);
BP_REF_TIMEUNIT_OPTIONS = null;
BP_REF_AUDIO_DOMAIN_OPTIONS = null;
BP_TMP_BUFF = null;
BP_TMP_BUFFINFO = null;
BP_TMP_ROLL_OUTPUT = null;
BP_INF = 1./0;
BP_RAND_RES = 2147483648;
BP_RNG = {max.random 2147483648 @seed 1};
BP_URN = null;
BP_SCRIPT_PATH = null;

## ------------------------------------------------------------

$addref = (
    $name, $description, $arguments, $output, $category = BP_REF_LABEL_UTILS, $anmodes = 0...3, $ankeys = null -> (
        ## check if reference belongs to analysis/descriptor function
        if $category == BP_REF_LABEL_ANALYSIS then (
            ## check if descriptor supports multiple modes
            $mode = $arguments."@mode";
            if $mode != null then (
                ## if so, filter out unsupported modes
                $mode."options:" = for $i in $anmodes collect ($mode."options:"):($i + 1)
            );
            ## re-assign modified arguments
            $arguments."@mode" = $mode
        );
        ## if function has arguments, split required from optional ones.
        if $arguments != null then (
            $required = null;
            $optional = null;
            for $arg in $arguments do if ($arg::1)."default:" == null then (
                $required _= $arg 
            ) else (
                $optional _= $arg
            );
            $arguments = ($required &&& [ "required:" $required ]) ($optional &&& [ "optional:" $optional ])
        );
        
        BP_REF.$category _= [
            $name
            [ "description:" $description ] 
            [ "arguments:" ($arguments ||| "none") ] 
            (
                ## if function is a descriptor, show name of analysis keys
                if $category == BP_REF_LABEL_ANALYSIS then (
                    $ankeys = $ankeys ||| $name;
                    $ankeys = for $k in $ankeys collect [ "'" + $k + "'" ];
                    [ "resulting buffer keys:" $ankeys ]
                )
            )
            [ "output:" ($output ||| "null") ]
        ]
    )
);

## ------------------------------------------------------------

$addarg = (
    $name, $description, $type = "list", $default = null, $options = null -> (
        [
            "@" + $name + (if $default == null then " ?" else "")
            [ "description:" $description ]
            [ "type:" $type ]
            ($default &&& [ "default:" $default ])
            ($options &&& [ "options:" $options ])
        ]
    )
);

$addopt = (
    $value, $description -> (
        [ (if $description then (tosymbol($value) + ":") else $value) $description ]
    )
);

$addout = (
    $description, $type -> [ "description:" $description ] [ "type:" $type ]
);

## ------------------------------------------------------------

BP_DISPATCH_FUNC = (
    $to, $msg -> (
        $do1 = [ $to $msg ];
        null
    )
);

## ------------------------------------------------------------

BP_GET_PATH_INFO_FUNC = (
    $x,
    $locate = 0 -> (
        BP_DISPATCH_FUNC("pathinfo", $x);
        if BP_PATH_INFO == null then (
            printerror("invalid path:" $x) 
        ) else if $locate == 1 && BP_PATH_INFO."extension" != null && BP_PATH_INFO."exists" == 0 then (
            printerror("file not found:" $x)
        );
        BP_PATH_INFO
    )
);

## ------------------------------------------------------------

parsepath = (
    $path -> (
        $info = BP_GET_PATH_INFO_FUNC($path);
        [for $key in "name" "parent" "extension" collect (
                $val = $info.$key;
                $val &&& [ $key $val ]
            )
        ]
    )
);

$addref(
    @name "parsepath",
    @description "Parses a given path into key-value pairs for the following properties: 'name' (file or folder name), 'parent' (path of parent directory), and 'extension' (file extension, if not a folder). See #getkey.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path" @type "symbol" @description "file or folder path.")
    )
    @output $addout(@description "parsed path" @type "llll")
);

## ------------------------------------------------------------

thispath = (
    $parse = 0
    -> if $parse then BP_SCRIPT_PATH.parsepath() else BP_SCRIPT_PATH
);

$addref(
    @name "thispath",
    @description "Returns the path of the current script, as either a symbol or a parsed llll path. See #parsepath.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "parse" @default 0 @type "int" @description "parse path." @options 
            BP_REF_SWITCH_OPTIONS
        )
    )
    @output $addout(@description "path to current script" @type "llll")
);

## ------------------------------------------------------------

exists = (
    $path -> (
        $info = BP_GET_PATH_INFO_FUNC($file);
        $info."exists"
    )
);

$addref(
    @name "exists",
    @description "Checks if a file or folder exists. Returns 1 if true or 0 if false.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path" @type "symbol" @description "file or folder path.")
    )
    @output $addout(@description "1 if true, 0 if false." @type "int")
);

## ------------------------------------------------------------

readfolder = (
    $path,
    $filetype = "audio" -> (
        BP_TMP_FOLDER = null;
        $info = BP_GET_PATH_INFO_FUNC($path @locate 1);
        if $info."extension" != null then printerror("invalid folder path:" $path);
        $path = $info."path";
        $types = (
            [ "audio" "WAVE" "AIFF" "Mp3" ]
            [ "midi" "Midi" ]
            [ "text" "TEXT" ]
            [ "folder" "fold" ]
            [ "all" ]
        ).$filetype;
        if $filetype != "all" && $types == null then printerror("invalid file type:" $filetype);
        BP_DISPATCH_FUNC("folder",
            [ "types" $types ]
            [ $path ]
        );
        BP_TMP_FOLDER
    )
);

$addref(
    @name "readfolder",
    @description "Returns a list of file paths in specified folder directory.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path" @type "symbol" @description "folder path.")
        $addarg(@name "filetype" @default "'audio'" @type "symbol" @description "file type." @options
            $addopt(@value "'audio'" @description "audio" "files")
            $addopt(@value "'midi'" @description "midi" "files")
            $addopt(@value "'text'" @description "text" "files")
            $addopt(@value "'folder'" @description "folders")
            $addopt(@value "'all'" @description "all" "folder" "contents")
        )
    )
    @output $addout(@description "list of file paths", @type "list")
);

## ------------------------------------------------------------

BP_GET_BUFFER_INFO = (
    $buffer -> (
        BP_DISPATCH_FUNC("bufferinfo", $buffer);
        BP_TMP_BUFFINFO
    )
);

## ------------------------------------------------------------

printerror = (
    $text, $stop = 1 -> (
        BP_DISPATCH_FUNC("console",
            [ "code" $stop == 0 ]
            [ "type" 2 - $stop ]
            [ "text" $text ]
        );
        null
    )
);

## ------------------------------------------------------------

interrupt = (
    $print = null -> (
        BP_DISPATCH_FUNC("console",
            [ "code" 0 ]
            [ "type" 2 ]
            ($print &&& [ "text" $print ])
        );
        null
    )
);

$addref(
    @name "interrupt",
    @description "Disables communication between the current script and the bellplay~ application, interrupting any remaining script operations.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "print" @default "null" @type "anything" @description "something to print.")
    )
);

## ------------------------------------------------------------

BP_MEDIA_FILES = [
    [ "audio"
        "badinerie.wav"
        "drums.wav"
        "poem.wav"
        "singing.wav"
        "trumpet.wav"
    ]
    [ "midi"
        "bach.mid"
        "satie.mid"
    ]
    [ "llll"
        "corpus_demo.llll"
    ]
];

## ------------------------------------------------------------

inspect = (
    $buffer, 
    $label = null -> (
        $source = $buffer.getkey("source");
        if $source == null then (
            printerror("invalid buffer in inspect():" $buffer)
        ) else (
            BP_BUFFER_INSPECTOR _= [
                [ "label" $label ||| $source ]
                [ "data" left($buffer, 1) ]
            ]
        );
        $buffer
    )
);

$addref(
    @name "inspect",
    @description "Adds input buffer to the buffer inspector window, which opens up once the script evaluation is over, displaying relevant buffer information — useful for debugging buffers.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "buffer" @type "llll" @description "media file type.")
        $addarg(@name "label" @default "null" @type "symbol/null" @description "optional buffer inspector label.")
    )
    @output $addout(@description "buffer", @type "llll")
);

## ------------------------------------------------------------

getmediafiles = (
    $type = null -> (
        if $type == null then (
            for $x in BP_MEDIA_FILES::1 collect right($x::1, 1)
        ) else BP_MEDIA_FILES.getkey($type)
    )
);

$addref(
    @name "getmediafiles",
    @description "Returns a list of built-in media files in bellplay~.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "type" @default "null" @type "symbol/null" @description "media file type" @options
            $addopt(@value "null" @description "all" "files")
            $addopt(@value "'audio'" @description "audio" "files")
            $addopt(@value "'midi'" @description "midi" "files")
            $addopt(@value "'llll'" @description "llll" "files")
        )
    ),
    @output $addout(@description "list of media files", @type "list")
);

## ------------------------------------------------------------

BP_NEWBUFF_FUNC = (
    $source,
    $offset = 0,
    $info = 1,
    $pitch = 6000,
    $extras = null -> (
        if $source == null then printerror("null buffer encountered");
        $buffer = (
            [ "source" $source ]
            [ "sr" BP_SR ]
            [ "numchannels" 1 ]
            [ "duration" 50 ]
            [ "offset" $offset ]
            [ "pitch" $pitch ]
        );
        $info = if $info == 1 then BP_GET_BUFFER_INFO($source);
        $info _= [ "source_end" if $info then $info."duration" else $buffer."duration" ];
        $buffer = [$buffer];
        for $x in $info $extras do (
            $key = $x:(1 1);
            ($key &&& $buffer = setkey($buffer, $key, $x.$key @mode 1))
        );
        $buffer
    )
);

## ------------------------------------------------------------

tosymbol = (
    $x -> (
        BP_DISPATCH_FUNC("sym", $x);
        BP_SYMBOL
    )
);

$addref(
    @name "tosymbol",
    @description "Casts input value as a symbol.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x",  @type "anything" @description "value to cast")
    ),
    @output $addout(@description "symbol", @type "symbol")
);

## ------------------------------------------------------------

isnan = ($x -> tosymbol($x) == 'nan');

$addref(
    @name "isnan",
    @description "Checks if the input argument is strictly a nan — i.e., 'not a number' — value.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x",  @type "anything" @description "value to check")
    ),
    @output $addout(@description "0 if false, 1 if true.", @type "int")
);

## ------------------------------------------------------------

BP_REF_BUFFER_KEYS_OPTIONS = sort(for $x in BP_NEWBUFF_FUNC("dummy" @info 0)::1 collect $addopt(@value "'" + $x::(1 1) + "'"));

BP_REF_TIMEUNIT_OPTIONS = (
    $addopt(@value 0, @description "milliseconds")
    $addopt(@value 1, @description "samples")
    $addopt(@value 2, @description "duration" "ratio")
    $addopt(@value 3, @description "milliseconds" "difference")
    $addopt(@value 4, @description "samples" "difference")
);

BP_REF_ANTIMEUNIT_OPTIONS = (
    $addopt(@value 0, @description "milliseconds")
    $addopt(@value 1, @description "samples")
    $addopt(@value 2, @description "duration" "ratio")
);

BP_REF_FREQUNIT_OPTIONS = (
    $addopt(@value 0 @description "Hertz")
    $addopt(@value 1 @description "BPM")
    $addopt(@value 2 @description "midicents")
    $addopt(@value 3 @description "MIDI")
);

BP_REF_PITCHUNIT_OPTIONS = (
    $addopt(@value 0 @description "midicents")
    $addopt(@value 1 @description "MIDI")
    $addopt(@value 2 @description "Hertz")
    $addopt(@value 3 @description "ratio")
);

BP_REF_AUDIO_DOMAIN_OPTIONS = (
    $addopt(@value 0, @description "frequency" "domain")
    $addopt(@value 1, @description "time" "domain")
);

BP_REF_PITCH_FORMAT_OPTIONS = (
    $addopt(@value 0 @description "cents")
    $addopt(@value 1 @description "MIDI" )
    $addopt(@value 2 @description "Hertz")
    $addopt(@value 3 @description "frequency" "ratio")
);

BP_REF_SWITCH_OPTIONS = (
    $addopt(@value 0 @description "off")
    $addopt(@value 1 @description "on" )
);

BP_REF_NORMALIZE_OPTIONS = (
    $addopt(@value 0 @description "never")
    $addopt(@value 1 @description "always")
    $addopt(@value 2 @description "overload" "protection" "only" )
);

BP_REF_WINDOW_OPTIONS = (
    $addopt(@value "'rectangular'")
    $addopt(@value "'triangular'")
    $addopt(@value "'sine'")
    $addopt(@value "'hann'")
    $addopt(@value "'hamming'")
    $addopt(@value "'blackman'")
    $addopt(@value "'nuttall'")
    $addopt(@value "'blackmannuttall'")
    $addopt(@value "'blackmanharris'")
    $addopt(@value "'gaussian'")
    $addopt(@value "'sqrthann'")
    $addopt(@value "'sqrthamming'")
);

BP_REF_AMPUNIT_OPTIONS = (
    $addopt(@value 0, @description "linear")
    $addopt(@value 1, @description "decibels")
);

BP_REF_CURVE_OPTIONS = (
    $addopt(@value 0, @description "linear")
    $addopt(@value 1, @description "sine")
    $addopt(@value 2, @description "curve")
    $addopt(@value 3, @description "s-curve")
);

BP_REF_RESAMPLINGMODE_OPTIONS = (
    $addopt(@value "'sinc'")
    $addopt(@value "'nearest" "neighbor'")
    $addopt(@value "'sample" "and" "hold'")
    $addopt(@value "'linear'")
    $addopt(@value "'quad'")
    $addopt(@value "'cubic'")
);

BP_REF_RESAMPLINGPOLICY_OPTIONS = (
    $addopt(@value 0 @description "don't")
    $addopt(@value 1 @description "to" "lowest")
    $addopt(@value 2 @description "to" "highest")
    $addopt(@value 3 @description "to" "most" "common")
    $addopt(@value 4 @description "to" "max." "current")
);

BP_REF_ESSENTIA_ANALYSIS_OPTIONS = (
    $addopt(@value 0 @description "global")
    $addopt(@value 1 @description "time" "series")
    $addopt(@value 2 @description "time-tagged" "time" "series")
    $addopt(@value 3 @description "buffer")
);

BP_REF_ESSENTIA_ONSET_METHOD = (
    $addopt(@value "'hfc'" @description "high frequency content.")
    $addopt(@value "'complex'" @description "the complex-domain spectral difference function.")
    $addopt(@value "'complex_phase'" @description "the simplified complex-domain spectral difference function taking into account phase changes, weighted by magnitude.")
    $addopt(@value "'flux'" @description "spectral flux.")
    $addopt(@value "'melflux'" @description "similar to spectral flux, but using half-rectified energy changes in Mel-frequency bands.")
    $addopt(@value "'rms'" @description "difference function, measuring the half-rectified change of the RMS of the magnitude spectrum.")
);

## ------------------------------------------------------------

addmarker = (
    $onset,
    $names = null -> (
        if $onset == null then printerror("You must provide a value for @onset in addmarker()");
        BP_DISPATCH_FUNC("roll", "addmarker" $onset ($names &&& [ $names ]) ||| [])
    )
);

$addref(
    @name "addmarker"
    @description "Inserts a marker into the transcription score, given an onset time and, optionally, a list of names associated with that marker, as a list."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "onset" @type "int/float" @description "marker onset position.")
        $addarg(@name "names" @default "null" @type "symbol/list/null" @description "optional list of marker names, each as a symbol")
    )
);

## ------------------------------------------------------------

pcdiff = (
    $a, $b, $mod = 12 -> ( 
        if $a == null || $b == null then (
            printerror("you must provide values for both @a and @b in pcdiff()")
        );
        $a = fmod($a, $mod); 
        $b = fmod($b, $mod); 
        $da = $b - $a;
        $db = $da + $mod * -sgn($da); 
        $mask = max(0, sgn(abs($db) - abs($da)));
        $da * $mask + $db * (1 - $mask)
    ) 
);

$addref(
    @name "pcdiff",
    @description "Signed pitch class difference.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "a",  @type "int/float/list",@description "pitch classes.")
        $addarg(@name "b", @type "int/float/list",@description "pitch classes.")
    ),
    @output $addout(@description "signed difference", @type "int/float/list")
);

## ------------------------------------------------------------

buildcorpus = (
    $files,
    $descriptors,
    $outpath = null,
    $segmode = 1,
    $overlap = 1,
    $segsize = 100,
    $alpha = 0.1,
    $delay = 5,
    $framerate = 86.1328,
    $silencethreshold = 0.02 -> (
        if $files == null || $descriptors == null then printerror("You must provide a value for @files and @descriptors in buildcorpus().");
        if $files.contains() != 16 then printerror('All elements in @files must by of type symbol in buildcorpus().');
        if $segmode.intersection(0...2) == null then printerror("Invalid value for @segmode in buildcorpus():" $segmode);
        if $segsize <= 0 then printerror("segmentation size must be greater than zero in buildcorpus().");

        if $outpath != null then (
            $pathinfo = BP_GET_PATH_INFO_FUNC($outpath);
            if $pathinfo."extension" != ".llll" then (
                printerror($outpath "is not a valid corpus extension.")
            ) else if $path."type" == 3 then (
                printerror($outpath "is not a valid @outpath in buildcorpus().")
            );
            $outpath = $pathinfo."path" + $pathinfo."extension"
        );

        BP_DATABASE_OUTPUT = null;

        $corpus = null;

        $onsetdescriptor = onsets(
            @alpha $alpha
            @delay $delay
            @framerate $framerate
            @silencethreshold $silencethreshold
        );
        
        for $file in $files do (
            $pathinfo = BP_GET_PATH_INFO_FUNC($file);
            if ($pathinfo."extension").intersection(BP_SUPPORTED_AUDIO_FORMATS) == null then (
                printerror($file "is not a valid audio file.")
            ) else (
                $path = $pathinfo."path" + $pathinfo."extension";
                $buff = importaudio($path);
                $segref = $buff;
                $segments = null;
                if $segmode != 0 then (
                    if $segmode == 1 then (
                        $buff = $buff.analyze(
                            @descriptors $onsetdescriptor
                        );
                        $onsets = $buff.getkey("onsets") ||| 0;
                        $durations = ($onsets $buff.getkey("source_end")).x2dx()
                    ) else if $segmode == 2 then (
                        $hopsize = $segsize / $overlap;
                        $numsegs = max(1, ceil($buff.getkey("duration") / $hopsize));
                        $onsets = (0...($numsegs - 1)) * $hopsize;
                        $durations = $segsize :* $onsets.length()
                    );
                    for $onset in $onsets, $duration in $durations do (
                        $segments _= $segref.setkey("offset", $onset).setkey("duration", $duration)
                    )
                ) else (
                    $segments _= $buff
                );
                for $seg in $segments do (
                    $seg = $seg.analyze(
                        @descriptors $descriptors
                    ).setkey("source", $path);
                    $corpus _= $seg
                )
            )
        );
        $template = for $keyval in $corpus::1 with @unwrap 1 collect (
            $key = $keyval.left(1);
            $val = $keyval.right(1);
            $type = null;
            $contains = $val.contains();
            $type = if $val == null || $val.length() > 1 || $val.depth() > 1 then (
                "l"
            ) else if $contains == 2 then (
                "i"
            ) else if $contains == 4 then (
                "r"
            ) else if $contains == 8 then (
                "f"
            ) else if $contains == 16 then (
                "s"
            ) else if $contains == 256 then (
                "p"
            ) else (
                "l"
            );
            [ $key $type ]
        );
        BP_DISPATCH_FUNC("db", [ "erase" ] [ "addtable" "buffers" $template ]);
        for $entry in $corpus do (
            $entry = ($entry::1).map(
                ## nullify inf and nan values
                $x -> (
                    if $x.contains() <= 8 && ($x.abs() == BP_INF || $x.isnan()) then null else $x
                )
            @maxdepth -1);
            BP_DISPATCH_FUNC("db", [ "addentry" "buffers" $entry ])
        );

        if $outpath != null then (
            BP_DISPATCH_FUNC("db", [ "write" $outpath ] )
        )
    )
);

$addref(
    @name "buildcorpus",
    @description "Creates a buffer corpus from a list of audio file paths, and writes it into disk as a .llll file. See #analyze and #onsets.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "files" @type "symbol/list" @description "list of audio file paths.")
        $addarg(@name "descriptors" @type "llll" @description "list of audio descriptors.")
        $addarg(@name "outpath" @default "null" @type "symbol/null" @description "optional output corpus path, as an .llll file. If null, the corpus is not written into memory.")
        $addarg(@name "segmode" @default 1 @type "int" @description "buffer segmentation mode." @options 
            $addopt(@value 0 @description "no" "segmentation")
            $addopt(@value 1 @description "'onsets'-based" "segmentation")
            $addopt(@value 2 @description "blind" "segmentation")
        )
        $addarg(@name "overlap" @default 1 @type "int/float" @description "segment overlap factor, when @segmode is 2.")
        $addarg(@name "segsize" @default 100 @type "int" @description "segment duration in milliseconds, when @segmode is 2.")
        $addarg(@name "alpha" @default 0.1 @type "float" @description "proportion of the mean included to reject smaller peaks — filters very short onsets.")
        $addarg(@name "delay" @default 5 @type "int" @description "number of frames used to compute the threshold — size of short-onset filter.")
        $addarg(@name "framerate" @default 86.1328 @type "float" @description "frames per second.")
        $addarg(@name "silencethreshold" @default 0.02 @type "float" @description "threshold for silence.")
    )
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        if $filepath == null then (
            printerror("you must provide a value for @filepath in setcorpus()")
        );
        $pathinfo = BP_GET_PATH_INFO_FUNC($filepath @locate 1);
        $path = $pathinfo."path";
        $extension = $pathinfo."extension";
        if $extension != ".llll" then printerror(if $extension == null then "you must provide a file path" else "invalid corpus extension:" $extension);
        BP_DATABASE_OUTPUT = null;
        BP_DISPATCH_FUNC("db", [ "read" $path + $extension ])
    )
);

$addref(
    @name "setcorpus",
    @description "Loads an audio corpus, given a path to a .llll file. See #query function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    )
);

## ------------------------------------------------------------

getcorpuskeys = (
   $typed = 1 -> (
        BP_DISPATCH_FUNC('db', [ "getcols" ]);
        $keys = (BP_DATABASE_OUTPUT::1).right(1);
        if $typed == 1 then $keys else for $x in $keys collect $x.flat():1
    )
);

$addref(
    @name "getcorpuskeys",
    @description "Returns a list with the current corpus' keys. See #setcorpus, #buildcorpus, and #query.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "typed", @default 1 @type "int", @description "include the data type for each key." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "corpus keys", @type "list/llll")
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        if $x == null || $i == null then (
            printerror("you must provide values for @x and @i in samplelist()")
        );
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

$addref(
    @name "samplelist",
    @description "Samples an interpolated value from a numeric list given a normalized index.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x", @type "list", @description "list to sample from.")
        $addarg(@name "i", @type "list", @description "normalized sampling index.")
    ),
    @output $addout(@description "interpolated sample", @type "int/float/list")
);

## ------------------------------------------------------------

median = (
    $x -> (
        $x = $x.sort($sortfunc);
        $n = length($x);
        $odd = $n % 2;
        if $odd == 0 then (
            $i = ($n // 2);
            ($x:$i + $x:($i + 1)) * 0.5
        ) else (
            $x:(($n + 1) // 2)
        )
    )
);

$addref(
    @name "median",
    @description "Returns the median element of a numeric list.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x",  @type "list" @description "numeric list.")
    ),
    @output $addout(@description "median element", @type "int/float")
);

## ------------------------------------------------------------

mean = (
    $x, $weights = null -> (
        $N = length($x);
        if $weights != null then (
            if length($weights) != $N then printerror("the number of weights must match the number of elements in mean().");
            $x *= $weights;
            $N = reduce($weights, #+)
        );
        float(reduce($x, #+) / $N)
    )
);

$addref(
    @name "mean",
    @description "Returns the mean value of a numeric list.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x",  @type "list" @description "numeric list.")
        $addarg(@name "weights" @default "null" @type "list/null" @description "optional weights.")
    ),
    @output $addout(@description "mean value", @type "float")
);

## ------------------------------------------------------------

query = (
    $x = "SELECT * FROM buffers" -> (
        if $x == null then (
            printerror("you must provide a value for @x in query()")
        );
        BP_DISPATCH_FUNC("db", [ "query" $x ]);
        (if BP_DATABASE_OUTPUT == null then printerror("query did not yield any results:" tosymbol($x)));
        
        $sources = thin(for $buff in BP_DATABASE_OUTPUT collect $buff.getkey("source"));
        $sourcemap = for $source in $sources collect [ $source importaudio($source).getkey("source") ];
        BP_DATABASE_OUTPUT = for $buff in BP_DATABASE_OUTPUT collect $buff.mapkey("source", $x -^ $sourcemap -> $sourcemap.$x);    
        
        BP_DATABASE_OUTPUT
    )
);

$addref(
    @name "query",
    @description "Executes a #sqlite3 query on the current audio corpus, and returns the results. Every query should use 'buffers' as the table name. For instance: 'SELECT * FROM buffers'. See #setcorpus.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "query", @type "symbol", @default "'SELECT * FROM buffers'", @description "sqlite3 query.")
    ),
    @output $addout(@description "list of buffers", @type "llll")
);

## ------------------------------------------------------------

getkey = (
    $llll, $key -> (
        if $key == null || $llll == null then (
            printerror("you must provide values for both @llll and @key in getkey()") 
        ) else ($llll::1).$key
    )
);

$addref(
    @description "Returns value associated with an llll key."
    @name "getkey"
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "llll" @type "llll" @description "list to get key of.")
        $addarg(@name "key" @type "symbol" @description "name of llll key.")
    )
    @output $addout(@description "value associated with key" @type "anything")
);

## ------------------------------------------------------------

setkey = (
    $llll, $key, $val, $mode = 0 -> (
        if $key == null || $llll == null then (
            printerror("you must provide values for both @llll and @key in setkey()") 
        ) else (
            if $mode == 0 || ($llll::1).$key then [ ($llll::1).$key = $val ] else [ $llll::1 [ $key $val ] ] 
        )
    )
);

$addref(
    @name "setkey"
    @description "Sets the value of a given key in a llll. If @mode is 0 (default), values for non-existent keys are ignored."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "llll" @type "llll" @description "llll to modify.")
        $addarg(@name "key" @type "symbol" @description "name of llll key.")
        $addarg(@name "val" @type "anything" @description "new value for llll key.")
        $addarg(@name "mode" @default 0 @type "int" @description "behavior mode." @options 
            $addopt(@value 0 @description "only set values for existing keys")        
            $addopt(@value 1 @description "always set values and create new keys when necessary.")        
        )
    )
    @output $addout(@description "modified llll", @type "llll")
);

## ------------------------------------------------------------

mapkey = (
    $llll, $key, $func -> (
        if $key == null || $llll == null || $func == null then (
            printerror("you must provide values for @llll, @key, and @func and @key in mapkey().") 
        );
        setkey($llll, $key, $func(getkey($llll, $key), $llll))
    )
);

$addref(
    @name "mapkey"
    @description "Modifies an existing llll key via a lambda function."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "llll" @type "llll" @description "llll to modify.")
        $addarg(@name "key" @type "symbol" @description "name of llll key.")
        $addarg(@name "func" @type "lambda function" @description "lambda function with signature $currentvalue, $currentbuffer -> $newvalue.")
    )
    @output $addout(@description "modified llll" @type "llll")
);

## ------------------------------------------------------------

bpf = (
    $pts,
    ## by default, x axis is sorted and normalized
    $xfunc = ($x -> ($norm = maximum($x ||| 1.); sort(float($x) / if $norm != 0 then $norm else 1.))),
    $yfunc = null,
    $sfunc = null -> (
        $depth = depth($pts);
        $size = length($pts);
        if $depth == 1 then (
            for $p $i in $pts collect [ ($i - 1.) / max(1, $size - 1.) (if $yfunc then $yfunc($p) else $p) 0. ]
        ) else if $depth == 2 then (
            $cols = trans($pts);
            $x = [ if $xfunc then $xfunc($cols::1) else $cols::1 ];
            $y = [ if $yfunc then $yfunc($cols::2) else $cols::2 ];
            $slope = for $i in 1...$size collect ($pts::($i 3)) ||| 0;
            if $sfunc then (
                $slope = $sfunc($slope)
            );
            trans($x $y [ $slope ])
        )
    )
);

$addref(
    @name "bpf",
    @description "Formats an numeric list into a breakpoint function, in the form of [<x> <y> <slope>] tuples. By default, <x> is normalized to the 0-1 range. To prevent this, set @xfunc to null.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "pts" @type "list" @description "numeric list")
        $addarg(@name "xfunc" @default "<normalization_function>" @type "function/null" @description "optional lambda function for x axis")
        $addarg(@name "yfunc" @default "null" @type "function/null" @description "optional lambda function for y axis")
        $addarg(@name "sfunc" @default "null" @type "function/null" @description "optional lambda function for bpf slope")
    ),
    @output $addout(@description "breakpoint function" @type "llll")
);


## ------------------------------------------------------------

x2dx = ($x -> for $a in left($x, -1), $b in right($x, 1) collect $b - $a);

$addref(
    @name "x2dx"
    @description "Takes a list of numbers and returns the differences — i.e., deltas — between adjacent elements. Inverse of #dx2x."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "x" @type "list" @description "list of numeric values.")
    )
    @output $addout(@description "difference between adjacent elements, as a list." @type "list")
);

## ------------------------------------------------------------

dx2x = ($dx, $st = 0 -> $st for $x in $dx collect $st += $x);

$addref(
    @name "dx2x"
    @description "Takes a list of differences — i.e., deltas — and an optional starting value, and returns the cumulative sum between adjacent elements, as a list. Inverse of #x2dx."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "dx" @type "list" @description "list of differences/deltas.")
        $addarg(@name "st" @default 0 @type "int/float" @description "optional starting value.")
    )
    @output $addout(@description "cumulative sum of differences from starting value." @type "list")
);

## ------------------------------------------------------------

r2dr = ($r -> for $a in $r.left(-1), $b in $r.right(1) collect $b / $a);

$addref(
    @name "r2dr"
    @description "Takes a list of ratios or factors and returns the quotients between adjacent elements. Inverse of #dr2r."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "r" @type "list" @description "list of ratios.")
    )
    @output $addout(@description "list of quotients between adjacent elements" @type "list")
);

## ------------------------------------------------------------

dr2r = ($dr, $st = 1 -> ($r = $st; $r for $d in $dr collect ($r *= $d)));

$addref(
    @name "dr2r"
    @description "Takes a list of ratios and an optional starting value, and returns the cumulative multiplication between adjacent elements, as a list. Inverse of #r2dr."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "dr" @type "list" @description "list of ratios.")
        $addarg(@name "st" @default 1 @type "int/float" @description "starting value")
    )
    @output $addout(@description "cumulative multiplication between adjacent elements." @type "list")
);

## ------------------------------------------------------------

revbpf = (
    $bpf -> (
        bpf($bpf, 
            ($x -> dx2x(rev(x2dx($x)))), 
            ($y -> rev($y)), 
            ($s -> left($s, 1) rev(right($s, 1)) * -1)
        )
    )
);

$addref(
    @name "revbpf",
    @description "Reverses a breakpoint function. See #bpf.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breakpoint function to reverse")
    ),
    @output $addout(@description "breakpoint function", @type "llll")
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * float($outmax - $outmin) + $outmin
    )
);

$addref(
    @name "scale",
    @description "Scales an input value or list from a given range to another.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "value to scale.")
        $addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        $addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        $addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        $addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    ),
    @output $addout(@description "scaled input", @type "int/float/list/llll")
);

## ------------------------------------------------------------

rand = (
    $a = 1, $b = null -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, BP_RAND_RES), 0, BP_RAND_RES, $min, $max)
    )
);

$addref(
    @name "rand",
    @description "Random floating point number generator.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "a", @type "int/float", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b", @type "int/float/null", @description "max. value.")
    ),
    @output $addout(@description "random floating point number", @type "int/float")
);

## ------------------------------------------------------------

nearest = (
    $list, 
    $target -> (
        if $list == null || $target == null then printerror("you must provide values for @list and @target in nearest().");
        $list = $list.sort();
        $left = 1;
        $right = length($list);
        $nearest = null;  
        
        while $left <= $right do (
            $mid = ($left + $right) // 2;
            $midval = $list:$mid;
            
            ## update the nearest value
            if $nearest == null || (abs($midval - $target) < abs($nearest - $target)) then (
                $nearest = $midval
            );
            
            ## decision to move the search boundaries
            if $midval == $target then (
                ## exit loop as the exact match is the nearest
                $left = $right + 1
            ) else if $midval < $target then (
                ## Target might be in the right half
                $left = $mid + 1
            ) else (
                ## Target might be in the left half
                $right = $mid - 1
            )
        );
        ## The nearest value is returned as the last expression
        $nearest
    )
);

$addref(
    @name "nearest",
    @description "Given a target number, finds the nearest value in a numeric list via binary search.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "list", @type "list", @description "numeric list to search.")
        $addarg(@name "target", @type "int/float", @description "target number to find nearest value for.")
    ),
    @output $addout(@description "nearest value", @type "int/float")
);

## ------------------------------------------------------------

BP_RANDOM_CHOICE_FUNC = (
    $choices, 
    $n = 1, 
    $weights = null,
    $mode = 0 -> (
        if $mode == 0 then (
            $random = random;
            $rand = rand
        ) else (
            $random = xrandom;
            $rand = xrand
        );
        $len = length($choices);
        $sum = if $weights == null then 0 else reduce($weights, #+);
        for $i in 1...$n collect (
            if $sum == 0 then (
                $choices:$random(1, $len)
            ) else (    
                $choice = null;
                $prob = $rand() * $sum;
                for $x in $choices, $w in $weights as $choice == null with @iterationmode 1 do (
                    if $prob < $w then $choice = $x;
                    $prob -= $w 
                );
                $choice  
            )
        )
    )
);

## ------------------------------------------------------------

choose = (
    $choices, 
    $n = 1, 
    $weights = null -> (
        BP_RANDOM_CHOICE_FUNC($choices, $n, $weights)
    )
);

$addref(
    @name "choose",
    @description "Choose randomly one or more elements from a list, with optional probability weights.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "choices", @type "list", @description "list to choose from.")
        $addarg(@name "n", @default 1, @type "int", @description "number of random choices.")
        $addarg(@name "weights", @default "null" @type "list/null", @description "optional probability weights for each element.")
    ),
    @output $addout(@description "chosen elements" @type "anything")
);

## ------------------------------------------------------------

setseed = (
    $seed -> (
        if $seed.contains() == 2 then BP_RNG("seed" $seed) else printerror("invalid seed value:" $seed);
        null
    )
);

$addref(
    @name "setseed",
    @description "Sets the random seed for the #xrand, #xrandom, #xchoose, #xscramble, and #urn functions.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "seed", @type "int", @description "random seed")
    )
);

## ------------------------------------------------------------

xrand = (
    $a = 1,
    $b = null -> (
        $min = $a;
        $max = $b;
        if $max == null then (
            $max = $min;
            $min = 0
        );
        BP_RNG('bang').scale(0, 2147483647, $min, $max)
    )
);

$addref(
    @name "xrand",
    @description "Seed-based random floating point number generator. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "a" @default 1 @type "int/float", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b" @default "null" @type "int/float/null", @description "max. value.")
    ),
    @output $addout(@description "random number", @type "float")
);

## ------------------------------------------------------------

xrandom = (
    $a = 1,
    $b = null -> (
        xrand($a, $b).round().int()
    )
);

$addref(
    @name "xrandom",
    @description "Seed-based random integer number generator. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "a" @default 1 @type "int", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b" @default "null" @type "int/null", @description "max. value.")
    ),
    @output $addout(@description "random number", @type "integer")
);

## ------------------------------------------------------------

xchoose = (
    $choices, $n = 1, $weights = null -> BP_RANDOM_CHOICE_FUNC($choices, $n, $weights @mode 1)
);

$addref(
    @name "xchoose",
    @description "Choose randomly one or more elements from a list, with optional probability weights. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "choices", @type "list", @description "list to choose from.")
        $addarg(@name "n", @default 1, @type "int", @description "number of random choices.")
        $addarg(@name "weights", @default "null" @type "list/null", @description "optional probability weights for each element.")
    ),
    @output $addout(@description "chosen elements" @type "anything")
);

## ------------------------------------------------------------

xscramble = (
    $llll -> (
        $indices = 1...$llll.length();
        $order = for $id in $indices collect xrand();
        $indices = $indices.sort(@function $a, $b -^ $order -> $order:$a <= $order:$b);
        $llll:[$indices]
    )
);

$addref(
    @name "xscramble"
    @description "Seed-based random shuffling of elements. See #setseed."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "llll" @type "list/llll", @description "list to scramble.")
    )
    @output $addout(@description "scrambled list", @type "list/llll")
);

## ------------------------------------------------------------

initurn = (
    $size = 10, $id = 0, $useseed = 0 -> (
        $shuffler = if $useseed == 0 then scramble else xscramble;
        $urn = [
            "pool" (
                0...($size.max(1) - 1)
            ).$shuffler()
        ] ["size" $size];
        if BP_URN.$id == null then BP_URN _= [$id $urn] else BP_URN.$id = $urn;
        null
    )
);

$addref(
    @name "initurn"
    @description "Initializes a new unique random number generator (URN), given a size and a URN identifier. Once initialized, the identifier can be used to generate unique random numbers with the #urn function. This allows for independent URNs of different sizes to be used within the same script. If a URN associated with the identifier already exists, the URN is reset. The initialized URN can be optionally be seed-based. See #setseed."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "size" @default 10 @type "int", @description "number of unique random numbers.")
        $addarg(@name "id" @default 0 @type "int/float/symbol", @description "identifier for unique random number generator.")
        $addarg(@name "useseed" @default 0 @type "list/llll", @description "use random seed for URN associated with @id.")
    )
);

## ------------------------------------------------------------

urn = (
    $id = 0 -> (
        $urn = BP_URN.$id;
        if $urn == null then printerror("A unique random number generator with id of" $id "doesn't exist yet. Use initurn() to initialize a new unique random number generator.") else (
            $pool = $urn."pool";
            $next = $pool.left(1);
            $pool = $pool.right(1);
            if $pool == null then (
                initurn(
                    @size $urn."size" 
                    @id $id 
                    @useseed $urn."useseed"
                )
            ) else (BP_URN.$id."pool" = $pool);
            $next
        )
    )
);

$addref(
    @name "urn"
    @description "Returns a unique random number for a given URN identifier. Note that you must call #initurn first to initialize the URN."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "id" @default 0 @type "int/float/symbol", @description "identifier for URN.")
    )
    @output $addout(@description "unique random number", @type "int")
);

## ------------------------------------------------------------

atodb = ($a -> 20 * log10($a));

$addref(
    @name "atodb"
    @description "Linear amplitude to decibels conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "a" @type "int/float", @description "linear amplitude.")
    )
    @output $addout(@description "decibels", @type "int/float")
);

## ------------------------------------------------------------

dbtoa = ($db -> 10 ** ($db/20));

$addref(
    @name "dbtoa"
    @description "Decibels to linear amplitude conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        $addarg(@name "db" @type "int/float", @description "decibels.")
    )
    @output $addout(@description "linear amplitude.", @type "int/float")
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

$addref(
    @name "c2r",
    @description "Cents to ratio conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "cents" @type "list/int/float", @description "cents to convert.")
    ),
    @output $addout(@description "list of ratios", @type "int/float/list")
);

## ------------------------------------------------------------

octreduce = ($ratios -> $ratios * 2 ** -int(floor(log2($ratios))));

$addref(
    @name "octreduce",
    @description "Reduces ratios to fit within the 1-2 range.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "ratios", @type "list/int/rat/float", @description "ratios to reduce.")
    ),
    @output $addout(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

r2pc = (
    $ratios,
    $pc = 0 -> (
        $ref = c2r($pc * 100);
        r2c(octreduce($ratios * $ref)) / 100.
    )
);

$addref(
    @name "r2pc",
    @description "Ratio to pitch class conversion, assuming octave equivalence.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
        $addarg(@name "pc", @default 0 @type "int/float", @description "pitch class of fundamental")
    ),
    @output $addout(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

mc2pc = ($mc -> fmod($mc, 1200.) / 100);

$addref(
    @name "mc2pc",
    @description "midicent to pitch class conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "mc", @type "list/int/float", @description "midicents to convert.")
    ),
    @output $addout(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

r2mc = (
    $ratios,
    $mc = 6000 -> (
        f2mc(mc2f($mc) * $ratios)
    )
);

$addref(
    @name "r2mc",
    @description "Ratio to midicent conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
        $addarg(@name "mc", @default 6000 @type "int/float", @description "fundamental in midicents")
    ),
    @output $addout(@description "list of midicents", @type "list/int/float")
);

## ------------------------------------------------------------

r2c = (
    $ratios -> log2($ratios) * 1200
);

$addref(
    @name "r2c",
    @description "Ratio to cents conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
    ),
    @output $addout(@description "list of cents", @type "list/int/float")
);

## ------------------------------------------------------------

sortbykey = (
    $items, $key -> (
        sort($items, ($a, $b -^ $key -> (getkey($a, $key) < getkey($b, $key))))
    )
);

$addref(
    @name "sortbykey",
    @description "Sorts llll items by a given key.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "items", @type "llll", @description "items to sort.")
        $addarg(@name "key", @type "symbol", @description "key to sort by.")
    ),
    @output $addout(@description "list of sorted items", @type "llll")
);

## ------------------------------------------------------------

fold = $x -> abs(fmod($x * 2 + 1, 2) - 1);

$addref(
    @name "fold",
    @description "Triangular function. Linearly folds numeric values to the 0-to-1 range.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x", @type "int/float/list/llll", @description "input number.")
    ),
    @output $addout(@description "output number.", @type "int/float/list/llll")
);

## ------------------------------------------------------------

filterbuffers = (
    $buffers, $func, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $func -> (
                $func($x)
            )
        );
        finditems($buffers, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

pitchdiff = (
    $source, $targets -> (
        if $targets == null then (
            printerror("you must provide @targets in pitchdiff")
        );
        if $source > 0 && $source.isnan() == 0 then (
            $distances = (
                if $targets:1 < 12 then (
                    pcdiff($source / 100., $targets) * 100
                ) else (
                    $targets - $source
                )
            );
            $diff = $distances:(minmax(abs($distances)):2);
            if $diff.isnan() == 1 then 0 else $diff
        ) else 0
    )
);

$addref(
    @name "pitchdiff",
    @description "Given a list of target midicents and/or pitch classes, returns the signed difference between a pitch in midicents and the nearest midicent/pitch class target.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "pitch", @type "int/float", @description "reference pitch in midicents.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "signed difference to closest target, in cents.", @type "int/float")
);

## ------------------------------------------------------------

transcribe = (
    $buffer, 
    $onset = 0, 
    $pan = null, 
    $gain = null, 
    $detune = null, 
    $voice = 1, 
    $pitchkey = "pitch",
    $keepduration = 1 -> (
        if $voice > BP_SCORE_CONFIG."numvoices" then printerror("@voice value in transcribe() exceeds the number of voices. Use scoreconfig() to change the number of voices.");
        if $buffer == null then (
            printerror("attempt to pass a null value as @buffer in transcribe()")
        );
        ## unpack buffer
        $buffer = $buffer::1;

        ## check for non-zero detuning
        $rate = [ 11 (if $detune && $detune != 0 then c2r($detune)) ];

        ## get pitch value
        $mc = $pitchkey &&& ($buffer.$pitchkey).flat().left(1);

        $notehead = 85;
        
        if $mc == null || $mc <= 0 || $mc.isnan() then (
            $mc = 6000;
            $notehead = 88
        );

        $notehead = [ 23 $notehead ];

        ## keep copy before pitch shifting
        $mccopy = $mc; 
        
        ## check if detuning is applied
        if $rate::(1 2) then (
            ## update pitch value based on detuning
            $mc += r2c($rate::(1 2))
        ) else (
            ## nullify unused slot for optimization
            $rate = null
        );
        ## color note based on detuning
        $color = [ 6 fmod(abs(($mccopy - $mc) / 1200) + .66, 1) ];

        ## clean gain and panning slots
        $pan = if $pan != null then [ 2 bpf($pan) ];
        $gain = if $gain != null then [ 1 bpf($gain @yfunc $y -> $y * 127.) ];

        ## get chord velocity and duration
        $vel = if $gain then maximum(trans($gain.1)::2) else 64;
        $dur = $buffer."duration";

        if $keepduration == 0 && $rate != null then (
            $dur /= $rate::(1 2)
        );
        
        if $dur <= 0 then printerror("attempt to transcribe a buffer with duration of" $dur);
        
        ## make size slot based on duration
        $size = [ 4 scale(log2(min(16384, max(1, $dur))), 0, 14, 25, 150) ];

        ## format note and add to roll
        $note = [ $mc $dur $vel ["slots" [ 7 $buffer."source" ] [ 10 $buffer."offset" ] $pan $rate $gain $color $notehead $size ]];
        BP_DISPATCH_FUNC("roll", "addchord" ($voice ||| 1) [ $onset $note ])
    )
);

$addref(
    @name "transcribe",
    @description "Adds input buffer to the rendering sequence. See #render function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "buffer", @type "llll", @description "buffer to add to rendering sequence.")
        $addarg(@name "onset", @type "int/float", @default 0, @description "buffer onset in milliseconds.")
        $addarg(@name "pan", @type "int/float/list/llll", @default "null" @description "normalized panning value or envelope.")
        $addarg(@name "gain", @type "int/float/llll", @default "null" @description "linear gain value or envelope. Use the #gain function for values greater than 1.")
        $addarg(@name "detune", @type "int/float", @default "null" @description "detuning amount in cents.")
        $addarg(@name "voice", @type "int", @default 1 @description "voice assignment in score. See scoreconfig() function.")
        $addarg(@name "pitchkey", @type "symbol", @default "'pitch'" @description "key to use for pitch value in score transcription.")
        $addarg(@name "keepduration", @type "int", @default 1 @description "keep buffer's nominal duration value when detuning buffer via @detune.")
    )
);

## ------------------------------------------------------------

render = (
   $numchannels = 2, 
   $panmode = 0, 
   $sr = 48000, 
   $normalize = 0, 
   $play = 0, 
   $spread = 1,
   $fade = 5,
   $reset = 0,
   $process = null -> (
        if $numchannels < 1 then printerror("number of channels must be greater than 0");
        BP_DISPATCH_FUNC("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "fadein" $fade ]
            [ "fadeout" $fade ]
            [ "normalize" $normalize ]
            [ "spread" $spread ]
        );
        BP_DISPATCH_FUNC("roll", "getlength");
        BP_DISPATCH_FUNC("roll", "dump");
        BP_DISPATCH_FUNC("roll", "getdomain");
        ($process &&& BP_DISPATCH_FUNC("sampler", [ "process" $process ] ));
        ($play == 1 && BP_DISPATCH_FUNC("playtoggle", 1));
        ($reset == 1 && BP_DISPATCH_FUNC("roll", "clear"));
        BP_NEWBUFF_FUNC(@source BP_RENDER_BUFF)
    )
);

$addref(
    @name "render",
    @description "Triggers audio rendering of all transcribed buffers via #transcribe, and returns the rendered buffer. Note that it's possible to apply post-rendering processing by passing audio processing commands (e.g., #reverse, #freeverb, #clip, etc.) to the @process arguments, but these audio modifications won't be accurately reflected in the score transcription. See #process function.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        $addarg(@name "panmode", @type "int", @default 0, @description "panning mode." @options 
            $addopt(@value 0, @description "linear")
            $addopt(@value 1, @description "circular")
        )
        $addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        $addarg(@name "normalize", @type "int", @default 0, @description "audio normalization." @options 
            BP_REF_NORMALIZE_OPTIONS
        )
        $addarg(@name "play" @default 0 @type "int" @description "autoplay rendered buffer.", @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "spread" @default 1 @type "int/float" @description "multichannel panning spread, between 0 and 1.")
        $addarg(@name "fade" @default 5 @type "int/float" @description "fade in/out applied to every buffer, in milliseconds")
        $addarg(@name "reset", @default 0 @type "int", @description "remove all previously transcribed buffers after rendering." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "process" @default "null" @type "list/llll/null", @description "optional post-rendering audio processing commands.")
    )
    @output $addout(@description "rendered buffer" @type "llll")
);

## ------------------------------------------------------------

BP_SCORE_CONFIG = null;

scoreconfig = (
    $voicenames = "output",
    $clefs = "FFGG",
    $tonedivision = 8,
    $showdurations = 0,
    $midichannels = 1 -> (
        $config = for $clef in $clefs, $channel in $midicannels, $name in $voicenames with @iterationmode 1 collect (
            [ ($clef ||| "G") ($channel ||| 1) ($name ||| "output") ]
        );
        $numvoices = length($config);
        $config = trans($config);
        $clefs = $config::1;
        $midichannels = $config::2;
        $voicenames = $config::3;
        $config = (
            [ "numvoices" $numvoices ]
            [ "clefs" $clefs ]
            [ "midichannels" $midichannels ]
            [ "voicenames" $voicenames ]
        );
        $changes = for $param in $config collect (
            $key = $param::1;
            if BP_SCORE_CONFIG.$key != $param.$key then $param
        );
        BP_SCORE_CONFIG = $config;
        BP_DISPATCH_FUNC("roll", $changes);
        BP_DISPATCH_FUNC("roll", "showdurations" $showdurations);
        BP_DISPATCH_FUNC("roll", "tonedivision" left($tonedivision, 1))
    )
);

$addref(
    @name "scoreconfig",
    @description "Configures the score appearance, such as the clefs, voice names, tone division, etc. See #transcribe.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "voicenames", @default "'output'" @type "list/symbol", @description "voice names.")
        $addarg(@name "clefs", @default "'FFGG'" @type "list/symbol", @description "clef type for each voice, as a symbol." @options
            $addopt(@value "'G'" @description "treble" "clef")
            $addopt(@value "'F'" @description "bass" "clef")
            $addopt(@value "'FG'" @description "grand" "staff")
            $addopt(@value "'FFGG'" @description "full" "staff")
            $addopt(@value "'FGG'" @description "bass" "+" "treble" "clef")
            $addopt(@value "'FFG'" @description "double" "bass" "+" "treble" "clef")
            $addopt(@value "'FF'" @description "double" "bass" "clef")
            $addopt(@value "'GG'" @description "double" "treble" "clef")
            $addopt(@value "'G8va'" @description "8va" "treble" "clef")
            $addopt(@value "'G8vb'" @description "8vb" "treble" "clef")
            $addopt(@value "'G15ma'" @description "15ma" "treble" "clef")
            $addopt(@value "'G15mb'" @description "15mb" "treble" "clef")
            $addopt(@value "'F8va'" @description "8va" "bass" "clef")
            $addopt(@value "'F8vb'" @description "8vb" "bass" "clef")
            $addopt(@value "'F15ma'" @description "15ma" "bass" "clef")
            $addopt(@value "'F15mb'" @description "15mb" "bass" "clef")
            $addopt(@value "'Tenor'" @description "tenor" "clef")
            $addopt(@value "'Barytone'" @description "baritone" "clef")
            $addopt(@value "'Alto'" @description "alto" "clef")
            $addopt(@value "'Mezzo'" @description "mezzo" "clef")
            $addopt(@value "'Soprano'" @description "soprano" "clef")
            $addopt(@value "'Percussion'" @description "percussion" "clef")
        )
        $addarg(@name "tonedivision", @default 8 @type "int", @description "symbolic tone division." @options
            $addopt(@value 2 @description "semitones")
            $addopt(@value 4 @description "quarter" "tones")
            $addopt(@value 8 @description "eighth" "tones")
        )
        $addarg(@name "showdurations", @default 0 @type "int", @description "show note durations as lines" @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "midichannels", @default 1 @type "int/list", @description "midichannel for each voice")
    )
);

## ------------------------------------------------------------

read = (
    $path,
    $ignore = null -> (
        BP_LLLL_READ = null;
        $info = BP_GET_PATH_INFO_FUNC($path @locate 1);
        if (".txt" ".llll").intersection($info."extension") == null then (
            printerror("invalid file extension for @path in read().")
        );
        $path = $info."path" + $info."extension";
        BP_DISPATCH_FUNC("llllio", "read" "read" $path);
        BP_LLLL_READ
    )
);

$addref(
    @name "read",
    @description "Read .txt or native .llll data. The ignore attribute allows preventing some categories of symbols, such as parens, pitches and more, to be read according to the usual bell syntax.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path", @type "symbol", @description "input file path.")
        $addarg(@name "ignore" @default "null" @type "symbol/null" @description "The ignore attribute can be set to any combination of the following characters" @options 
            $addopt(@value "'l'" @description "parens inside symbols are not llll levels, but symbols composed by parens only are kept as llll levels!")
            $addopt(@value "'L'" @description "all parens are not parsed as llll levels")
            $addopt(@value "'p'" @description "ignore pitches, keep them as symbols")
            $addopt(@value "'r'" @description "ignore rationals, keep them as symbols")
            $addopt(@value "'e'" @description "ignore floating-point scientific notation, keep it as symbol")
            $addopt(@value "'s'" @description "keep the special symbols nil and null as symbols")
            $addopt(@value "'b'" @description "symbols with a backtick are interpreted literally, with the backtick included")
            $addopt(@value 0 @description "don't ignore anything")
            $addopt(@value 1 @description "ignore everything")
            $addopt(@value "'-'" @description "invert selection")
        )
    )
    @output $addout(@description "file content" @type "anything")
);

## ------------------------------------------------------------

write = (
    $data,
    $path,
    $escape = 3,
    $wrap = 0,
    $indent = 'tab',
    $maxdecimals = 10,
    $maxdepth = -1,
    $negativeoctaves = 0,
    $parens = 0 -> (
        $info = BP_GET_PATH_INFO_FUNC($path);
        if (".txt" ".llll").intersection($info."extension") == null then (
            printerror("invalid file extension for @path in write().")
        );
        $ext = $info."extension";
        $path = $info."path" + $ext;
        $cmd = if $ext == ".txt" then "writetxt" else "write";
        BP_DISPATCH_FUNC("llllio", "write"
            [ "data" $data ]
            [ "config" 
                [ "escape" $escape ]
                [ "wrap" $wrap ]
                [ "indent" $indent ]
                [ "maxdecimals" $maxdecimals ]
                [ "maxdepth" $maxdepth ]
                [ "negativeoctaves" $negativeoctaves ]
                [ "parens" $parens ]
                [ $cmd $path ]
            ]
        );
        BP_LLLL_READ
    )
);

$addref(
    @name "write",
    @description "Writes data into disk in either .txt or native .llll format.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "data", @type "anything", @description "data to write.")
        $addarg(@name "path", @type "symbol", @description "output file path.")
        $addarg(@name "escape" @default 3 @type "int" @description "escaping style" @options 
            $addopt(@value 0 @description "none")
            $addopt(@value 1 @description "backtick")
            $addopt(@value 2 @description "double" "quotes")
            $addopt(@value 3 @description "smart")
        )
        $addarg(@name "wrap" @default 0 @type "int" @description "column at which the text should be hard-wrapped in .txt format. 0 means no wrapping")
        $addarg(@name "indent" @default "'tab'" @type "symbol/int" @description "if value is integer, number of spaces per depth level used for indentation.")
        $addarg(@name "maxdecimals" @default 10 @type "int" @description "maximum number of decimal digits for .txt format.")
        $addarg(@name "maxdepth" @default -1 @type "int" @description "maximum depth level at which text indentation is performed for .txt format.")
        $addarg(@name "negativeoctaves" @default 0 @type "int" @description "use negative octaves, when in .txt format." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "parens" @default 0 @type "int" @description "use parens." @options 
            BP_REF_SWITCH_OPTIONS
        )
    )
);

## ------------------------------------------------------------

export = (
    $path, $stems = 0, $format = "float32" -> (
        ## get path info
        $pathinfo = BP_GET_PATH_INFO_FUNC($path);
        $path = $pathinfo.'path';
        $ext = $pathinfo.'extension';
        $filepath = $path + $ext;

        ## check file type
        if $ext.intersection(BP_SUPPORTED_AUDIO_FORMATS) != null then (
            ## get audio format
            BP_DISPATCH_FUNC("audioexport", [ "settings" [ "format" $format ] ] ["mode" $stems != 0] $pathinfo )
        ) else if $ext == ".mid" || $ext == ".midi" then (
            BP_DISPATCH_FUNC("roll", "exportmidi" $filepath)
        ) else if $ext == ".llll" then (
            BP_DISPATCH_FUNC("roll", "write" $filepath)
        ) else (
            printerror("file format is not supported:" $ext)
        )
    )
);

$addref(
    @name "export",
    @description "Exports the rendered output as either an audio (.wav/aif/aiff/mp3), midi (.mid/midi), or roll (.llll) file, given a output path. For audio files, mono stem files can be separately exported with the @stems argument. See #render function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path", @type "symbol", @description "output file path.")
        $addarg(@name "stems", @default 0 @type "int", @description "stem export mode for audio files." @options
            BP_REF_SWITCH_OPTIONS
        )
    )
);

## ------------------------------------------------------------

importaudio = (
    $path -> (
        BP_TMP_BUFF = null;
        if $path == null then printerror("You must provide a value for @path in importaudio()");
        $pathinfo = BP_GET_PATH_INFO_FUNC($path @locate 1);
        $ext = $pathinfo."extension";
        $path = $pathinfo."path";
        $filepath = $path + $ext;
        if $ext.intersection(BP_SUPPORTED_AUDIO_FORMATS) != null then (
            BP_DISPATCH_FUNC("import", [
                "audio"
                $filepath
            ])
        ) else (
            printerror(if $ext == null then "you must provide a file path" else "invalid file extension:" $ext)
        );
        BP_NEWBUFF_FUNC(@source BP_TMP_BUFF @extras [ "file" $filepath ])
    )
);

$addref(
    @name "importaudio",
    @description "Imports an audio file (.wav/aif/aiff/mp3) as a buffer, given a file path.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "path", @type "symbol", @description "input audio file path.")
    ),
    @output $addout(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

importmidi = (
    $path -> (
        BP_TMP_ROLL_OUTPUT = null;
        if $path == null then printerror("You must provide a value for @path in importmidi()");
        $pathinfo = BP_GET_PATH_INFO_FUNC($path @locate 1);
        $ext = $pathinfo."extension";
        $path = $pathinfo."path";
        $filepath = $path + $ext;
        if $ext == ".midi" || $ext == ".mid" then (
            BP_DISPATCH_FUNC("import", [
                "roll"
                $filepath
            ])
        ) else (
            printerror(if $ext == null then "you must provide a file path" else "invalid file extension:" $ext)
        );
        BP_TMP_ROLL_OUTPUT
    )
);

$addref(
    @name "importmidi",
    @description "Imports a midi file, as a list of events, each with the following keys: 'pitch' , 'velocity', 'onset', 'voice', 'channel', and 'duration'",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "path", @type "symbol", @description "input midi file path.")
    ),
    @output $addout(@description "midi events" @type "llll")
);

## ------------------------------------------------------------

hanning = ($length = 16 -> ($length -= 1; sin((pi * (0...$length)) / $length) ** 2.));

$addref(
    @name "hanning",
    @description "Generates a hanning window as a numeric list.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "length", @type "int", @default 16, @description "window length.")
    ),
    @output $addout(@description "hanning window" @type "list")
);

## ------------------------------------------------------------

#( 
    adapted from emmanuel jourdan: https://cycling74.com/forums/math-behind-function-curve
    NOTE: this is implementation is different from both bach's (closest) and Max.
)#

interpolate = (
    $x, $a, $b, $slope = 0 -> (
        $ca = 1.2;
        $cb = .41;
        $cc = .91;
        $m = 1e-20;
        $xrange = $b:1 - $a:1;
        $yrange = $b:2 - $a:2;
        if abs($slope) < .001 then (
            (($x - $a:1) / $xrange) * $yrange + $a:2
        ) else (
            if $slope < 0 then (
                $gx = ($b:1 - $x) / $xrange;
                $hp = (($m - $slope) * $ca) ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $b:2 - $gp * $yrange
            ) else (
                $gx = ($x - $a:1) / $xrange;
                $hp = (($slope + $m) * $ca)  ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $gp * $yrange + $a:2
            )
        )
    )
);

$addref(
    @name "interpolate",
    @description "Curve interpolation between two points.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "interpolation point")
        $addarg(@name "a", @type "list", @description "xy coordinates for point A")
        $addarg(@name "b", @type "list", @description "xy coordinates for point B")
        $addarg(@name "slope", @type "list", @default 0, @description "slope of curve between the two points, in the -1 to 1 range")
    ),
    @output $addout(@description "interpolated values" @type "int/float/list")
);

## ------------------------------------------------------------

samplebpf = (
    $bpf, $pts -> (
        $cols = trans($bpf);
        $xvals = $cols::1;
        $yvals = $cols::2;
        $cvals = $cols::3;
        $N = length($bpf);
        for $pt in $pts collect (
            $xdiffs = $xvals - $pt;
            $i = 1;
            $pos = null;
            while $i <= $N do (
                $dx = $xdiffs:$i;
                if $dx >= 0 then (
                    $pos = max(1, $i - 1);
                    $i = $N + 1
                ) else (
                    $i += 1
                )
            );
            $a = left(($bpf:$pos)::1, 2);
            $b = ($bpf:(min($pos + 1, $N)))::1;
            $slope = $b:3;
            $b = left($b, 2);
            interpolate($pt, $a, $b, $slope)
        )
    )
);

$addref(
    @name "samplebpf",
    @description "Samples an interpolated value from a breakpoint function, given a list of normalized indices. See #bpf function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breakpoint function")
        $addarg(@name "pts", @type "int/float/list", @description "sampling point/s")
    ),
    @output $addout(@description "interpolated bpf values" @type "int/float/list")
);

## ------------------------------------------------------------

analyze = (
    $buffer, 
    $descriptors,
    $winstartfromzero = 0,
    $framesize = 512,
    $hopsize = 512,
    $numframes = "auto",
    $overlap = 1.,
    $wintype = 'hann',
    $winnormalized = 1,
    $envattack = 10,
    $envrelease = 100,
    $onsetdetectionmethod = 'complex',
    $peaksmaxnum = 100,
    $peaksorderby = 'complex',
    $peaksmagthresh = 0,
    $peaksmaxfreq = 5000,
    $peaksminfreq = 0,
    $summary = 3,
    $summaryweight = 1,
    $summarypositive = 0,
    $ampunit = 0,
    $antimeunit = 1,
    $envtimeunit = 0,
    $frequnit = 0,
    $pitchunit = 0,
    $timeunit = 0,
    $yinmaxfreq = 22050,
    $yinminfreq = 20,
    $yintolerance = 1,
    $frametime = 0,
    $bufinterp = 0 -> (
        $source = $buffer.getkey("source");
        if $source == null then printerror("you must provide a value for @buffer in analyze().");
        if $descriptors == null then printerror("you must provide a value for @descriptors in analyze().");
        BP_ESSENTIA_OUTPUT = null;
        $source = $buffer.process(bpthru()).getkey("source");
        BP_DISPATCH_FUNC("essentia",
            [ "buffer" $source ]
            [ "settings"
                "@winstartfromzero" $winstartfromzero
                "@framesize" $framesize
                "@hopsize" $hopsize
                "@numframes" $numframes
                "@overlap" $overlap
                "@wintype" $wintype
                "@winnormalized" $winnormalized
                "@envattack" $envattack
                "@envrelease" $envrelease
                "@onsetdetectionmethod" $onsetdetectionmethod
                "@peaksmaxnum" $peaksmaxnum
                "@peaksorderby" $peaksorderby
                "@peaksmagthresh" $peaksmagthresh
                "@peaksmaxfreq" $peaksmaxfreq
                "@peaksminfreq" $peaksminfreq
                "@summary" $summary
                "@summaryweight" $summaryweight
                "@summarypositive" $summarypositive
                "@ampunit" $ampunit
                "@antimeunit" $antimeunit
                "@envtimeunit" $envtimeunit
                "@frequnit" $frequnit
                "@pitchunit" $pitchunit
                "@timeunit" $timeunit
                "@yinmaxfreq" $yinmaxfreq
                "@yinminfreq" $yinminfreq
                "@yintolerance" $yintolerance
                "@bufinterp" $bufinterp
            ]
            [ "descriptors"
                $descriptors
                (if $frametime then BP_ESSENTIA_WRAPPER_FUNC(@name 'frametime' @mode 1))
            ]
        );
        $features = for $x in BP_ESSENTIA_OUTPUT collect [ ($x::1).flat(1) ];
        $buffer = [ $buffer.flat(1) $features ]
    )
);

$addref(
    @name "analyze",
    @description "Applies a sequence of audio analysis operations to the input buffer, via audio descriptors. These descriptors are generated through functions (e.g., see #flux, #dissonance, #spectrum), which contain the parameters for that specific audio analysis.",
    @category BP_REF_LABEL_ANALYSIS,
    @arguments (
        $addarg(@name "buffer" @type "llll", @description "buffer to analyze.")
        $addarg(@name "descriptors" @type "llll" @description "list of audio descriptors.")
        $addarg(@name "winstartfromzero" @default 0 @type "int" @description "center first window at @framesize / 2 instead of 0." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "framesize" @default 2048 @type "int" @description "analysis frame size or window size.")
        $addarg(@name "hopsize" @default 1024 @type "int" @description "analysis hop size.")
        $addarg(@name "numframes" @default "'auto'" @type "int/symbol" @description "number of analysis frames." @options
            $addopt(@value "'auto'" @description "infer from @framesize and @hopsize.")
            $addopt(@value ">0" @description "ignores @hopsize.")
        )
        $addarg(@name "overlap" @default 1 @type "int" @description "overlap factor between analysis window size and hop size.")
        $addarg(@name "wintype" @default "'hann'" @type "int" @description "window type" @options
            BP_REF_WINDOW_OPTIONS
        )
        $addarg(@name "winnormalized" @default 1 @type "int" @description "normalize analysis windows to have an area of 1 and then scaled by a factor of 2.")
        $addarg(@name "envattack" @default 10 @type "int/float" @description "attack time for computing envelopes.")
        $addarg(@name "envrelease" @default 100 @type "int" @description "release time for computing envelopes.")
        $addarg(@name "onsetdetectionmethod" @default "'complex'" @type "symbol" @description "onset detection method." @options
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        $addarg(@name "peaksmaxnum" @default 100 @type "int" @description "maximum number of peaks for peaks analyis.")
        $addarg(@name "peaksorderby" @default "'complex'" @type "symbol" @description "ordering method of the peaks in the peaks analysis." @options 
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        $addarg(@name "peaksmagthresh" @default 0 @type "int/float" @description "magnitude threshold for the peaks analyis.")
        $addarg(@name "peaksmaxfreq" @default 5000 @type "int/float" @description "maximum frequency for the peaks analyis.")
        $addarg(@name "peaksminfreq" @default 0 @type "int/float" @description "minimum frequency for the peaks analyis.")
        $addarg(@name "summary" @default 3 @type "int" @description "summarization mode, for global analyses that are computed on a frame-by-frame basis." @options 
            $addopt(@value 0 @description "use" "first" "frame.")
            $addopt(@value 1 @description "use" "last" "frame.")
            $addopt(@value 2 @description "use" "middle" "frame.")
            $addopt(@value 3 @description "average" "through" "frames.")
            $addopt(@value 4 @description "median" "through" "frames.")
            $addopt(@value 5 @description "mode" "through" "frames.")
        )
        $addarg(@name "summaryweight" @default 1 @type "int" @description "summarization weight, when @summary is 4." @options 
            $addopt(@value 0 @description "none.")
            $addopt(@value 1 @description "rms.")
            $addopt(@value 2 @description "loudness.")
        )
        $addarg(@name "summarypositive" @default 0 @type "int" @description "only summarize with positive values." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "ampunit" @default 0 @type "int" @description "amplitude unit" @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "antimeunit" @default 1 @type "int" @description "analysis time unit" @options
            BP_REF_ANTIMEUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit" @default 0 @type "int" @description "envelope time unit" @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "frequnit" @default 0 @type "int" @description "frequency unit" @options 
            BP_REF_FREQUNIT_OPTIONS   
        )
        $addarg(@name "pitchunit" @default 0 @type "int" @description "pitch unit" @options 
            BP_REF_PITCHUNIT_OPTIONS
        )
        $addarg(@name "timeunit" @default 0 @type "int" @description "time unit"
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "yinmaxfreq" @default 22050 @type "int/float" @description "maximum frequency for the YIN analysis.")
        $addarg(@name "yinminfreq" @default 20 @type "int/float" @description "minimum frequency for the YIN analysis.")
        $addarg(@name "yintolerance" @default 1 @type "int/float" @description "tolerance for the YIN analysis.")
        $addarg(@name "frametime" @default 0 @type "int" @description "retrieve analysis window time positions as a separate feature." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "bufinterp" @default 0 @type "int" @description "interpolation mode" @options 
            $addopt(@value 0 @description "no" "interpolation")
            $addopt(@value 1 @description "lower" "neighbor")
            $addopt(@value 2 @description "linear")
        )
    ),
    @output $addout(@description "analyzed buffer" @type "llll")
);

## ------------------------------------------------------------

BP_ESSENTIA_WRAPPER_FUNC = (
    $name,
    $settings,
    $output,
    $mode = 0,
    $modes = 0...3 -> (
        $mode = intersection($mode, $modes);
        if $mode == null then (
            printerror("invalid value for @mode in" $name "descriptor.")
        ) else (
            $mode = ("" "..." ":::" "~"):($mode + 1);
            [ 
                [ "name" $name + $mode ] 
                [ "settings" 
                    $settings
                ] 
                [ "output" $output ||| $name ] 
            ]
        )
    )
);

## ------------------------------------------------------------

effectiveduration = (
    $thresholdratio = 0.02,
    $samplerate = 44100 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "effectiveduration"
            @settings (
                "@samplerate" $samplerate
                "@thresholdratio" $thresholdratio
            )
        )
    )
);

$addref(
    @name "effectiveduration",
    @description "Audio descriptor to compute the effective duration of an envelope signal. The effective duration is a measure of the time the signal is perceptually meaningful. This is approximated by the time the envelope is above or equal to a given threshold and is above the -90db noise floor. This measure allows to distinguish percussive sounds from sustained sounds but depends on the signal length. By default, this algorithm uses 40% of the envelope maximum as the threshold which is suited for short sounds. Note, that the 0% thresold corresponds to the duration of signal above -90db noise floor, while the 100% thresold corresponds to the number of times the envelope takes its maximum value. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "thresholdratio" @default 0.02 @type "int/float" @description "ratio of the envelope maximum to be used as the threshold.")
    )
    @output $addout(@description "effectiveduration descriptor" @type "llll")
);

## ------------------------------------------------------------

envmaxtime = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "envmaxtime"));

$addref(
    @name "envmaxtime",
    @description "Audio descriptor to extract the time at which the global maxima of the buffer's envelope occurs. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS,
    @output $addout(@description "envmaxtime descriptor" @type "llll")
);

## ------------------------------------------------------------

envmintime = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "envmintime"));

$addref(
    @name "envmintime",
    @description "Audio descriptor to extract the time at which the global minima of the buffer's envelope occurs. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS,
    @output $addout(@description "envmintime descriptor" @type "llll")
);

## ------------------------------------------------------------

pitchyin = ( 
    $framesize = 2048,
    $interpolate = 1,
    $maxfrequency = 22050,
    $minfrequency = 20,
    $samplerate = 44100,
    $tolerance = 0.15,
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "pitchyin"
            @settings (
                "@framesize" $framesize
                "@interpolate" $interpolate
                "@maxfrequency" $maxfrequency
                "@minfrequency" $minfrequency
                "@samplerate" $samplerate
                "@tolerance" $tolerance
            )
            @output "pitchyin" "pitchyin_confidence"
            @mode $mode
        )
    )
);

$addref(
    @name "pitchyin",
    @description "Audio descriptor to estimate the fundamental frequency of a monophonic buffer. It is an implementation of the Yin algorithm for computations in the time domain. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "pitchyin" "pitchyin_confidence"
    @arguments (
        $addarg(@name "framesize" @default 2048 @type "int" @description "number of samples in the input frame.")
        $addarg(@name "interpolate" @default 1 @type "int" @description "enable interpolation." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "maxfrequency" @default 22050 @type "int/float" @description "the maximum allowed frequency.")
        $addarg(@name "minfrequency" @default 20 @type "int/float" @description "the minimum allowed frequency.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the input audio.")
        $addarg(@name "tolerance" @default 0.15 @type "int/float" @description "tolerance for peak detection.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "pitchyin descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## snr = ( 
##     $maalpha = 0.95,
##     $mmsealpha = 0.98,
##     $noisealpha = 0.9,
##     $framesize = 512,
##     $noisethreshold = 0.01,
##     $samplerate = 44100,
##     $usebroadbadnoisecorrection = 1,
##     $mode = 0 -> (
##         BP_ESSENTIA_WRAPPER_FUNC(
##             @name "snr"
##             @settings (
##                 "@maalpha" $maalpha
##                 "@mmsealpha" $mmsealpha
##                 "@noisealpha" $noisealpha
##                 "@framesize" $framesize
##                 "@noisethreshold" $noisethreshold
##                 "@samplerate" $samplerate
##                 "@usebroadbadnoisecorrection" $usebroadbadnoisecorrection
##             )
##             @mode $mode
##         )
##     )
## );

## $addref(
##     @name "snr",
##     @description "Audio descriptor to compute the signal-to-noise ratio for a buffer in a frame-wise manner. The algorithm assumes that the noise is gaussian and that there is a region of noise, without signal, at the beginning of the buffer in order to estimate the power spectral density of the noise. See #analyze.",
##     @category BP_REF_LABEL_ANALYSIS,
##     @arguments (
##         $addarg(@name "maalpha" @default 0.95 @type "int/float" @description "alpha coefficient for the EMA SNR estimation.")
##         $addarg(@name "mmsealpha" @default 0.98 @type "int/float" @description "alpha coefficient for the MMSE estimation.")
##         $addarg(@name "noisealpha" @default 0.9 @type "int/float" @description "alpha coefficient for the EMA noise estimation.")
##         $addarg(@name "framesize" @default 512 @type "int" @description "size of the input frame.")
##         $addarg(@name "noisethreshold" @default 0.01 @type "int/float" @description "threshold to detect frames without signal.")
##         $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal.")
##         $addarg(@name "usebroadbadnoisecorrection" @default 1 @type "int" @description "flag to apply the broadband noise correction factor." @options 
##             BP_REF_SWITCH_OPTIONS
##         )
##     )
##     @output $addout(@description "snr descriptor" @type "llll")
## );

## ------------------------------------------------------------

spectralkurtosis = (
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralkurtosis"
            @mode $mode
            @modes 0...2
        )
    )
);

$addref(
    @name "spectralkurtosis"
    @description "Audio descriptor to compute the spectral kurtosis of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralkurtosis descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalkurtosis = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "temporalkurtosis"));

$addref(
    @name "temporalkurtosis"
    @description "Audio descriptor to compute the temporal kurtosis of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output $addout(@description "temporalkurtosis descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralskewness = (
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralskewness"
            @mode $mode
        )
    )
);

$addref(
    @name "spectralskewness"
    @description "Audio descriptor to compute the spectral skewness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralskewness descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalskewness = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "temporalskewness"));

$addref(
    @name "temporalskewness"
    @description "Audio descriptor to compute the temporal skewness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output $addout(@description "temporalskewness descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralspread = (
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralspread"
            @mode $mode
        )
    )
);

$addref(
    @name "spectralspread"
    @description "Audio descriptor to compute the spectral spread of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralspread descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalspread = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "temporalspread"));

$addref(
    @name "temporalspread"
    @description "Audio descriptor to compute the temporal spread of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output $addout(@description "temporalspread descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralvariance = (
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralvariance"
            @mode $mode
        )
    )
);

$addref(
    @name "spectralvariance"
    @description "Audio descriptor to compute the spectral variance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralvariance descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalvariance = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "temporalvariance"));

$addref(
    @name "temporalvariance"
    @description "Audio descriptor to compute the temporal variance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output $addout(@description "temporalvariance descriptor" @type "llll")
);

## ------------------------------------------------------------

energy = (
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "energy"
            @mode $mode
        )
    )
);

$addref(
    @name "energy"
    @description "Audio descriptor to compute the energy of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "energy descriptor" @type "llll")
);

## ------------------------------------------------------------

energyband = (
    $startcutofffrequency = 0,
    $stopcutofffrequency = 100,
    $samplerate = 44100,
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "energyband"
            @settings (
                "@startcutofffrequency" $startcutofffrequency
                "@stopcutofffrequency" $stopcutofffrequency
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

$addref(
    @name "energyband"
    @description "Audio descriptor to compute energy in a given frequency band of a spectrum including both start and stop cutoff frequencies. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "startcutofffrequency" @type "int" @default 0 @description "start frequency from which to sum the energy.")
        $addarg(@name "stopcutofffrequency" @type "int" @default 100 @description "stop frequency to which to sum the energy.")
        $addarg(@name "samplerate" @type "int" @default 44100 @description "audio sampling rate.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "energyband descriptor" @type "llll")
);

## ------------------------------------------------------------

dissonance = ($mode = 0 -> BP_ESSENTIA_WRAPPER_FUNC(@name "dissonance" @mode $mode));

$addref(
    @name "dissonance"
    @description "Audio descriptor to compute the sensory dissonance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "dissonance descriptor" @type "llll")
);

## ------------------------------------------------------------

strongpeak = ($mode = 0 -> BP_ESSENTIA_WRAPPER_FUNC(@name "strongpeak" @mode $mode));

$addref(
    @name "strongpeak"
    @description "Audio descriptor to compute the strong peak of a buffer, defined as the ratio between the spectrum's maximum peak's magnitude and the 'bandwidth' of the peak above a threshold — i.e., half its amplitude. This ratio reveals whether the spectrum presents a very 'pronounced' maximum peak — i.e., the thinner and the higher the maximum of the spectrum is, the higher the ratio value. Note that 'bandwidth' is defined as the width of the peak in the log10-frequency domain. Using the log10-frequency domain allows this algorithm to compare strong peaks at lower frequencies with those from higher frequencies. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "strongpeak descriptor" @type "llll")
);

## ------------------------------------------------------------

inharmonicity = ($mode = 0 -> BP_ESSENTIA_WRAPPER_FUNC(@name "inharmonicity" @mode $mode));

$addref(
    @name "inharmonicity"
    @description "Audio descriptor to calculate the inharmonicity of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "inharmonicity descriptor" @type "llll")
);

## ------------------------------------------------------------

zerocrossingrate = (
    $threshold = 0,
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "zerocrossingrate" 
            @mode $mode
            @settings (
                "@threshold" $threshold
            )
        )
    )
);

$addref(
    @name "zerocrossingrate"
    @description "Audio descriptor to compute the zero-crossing rate of a buffer, defined as the number of sign changes between consecutive signal values divided by the total number of values. Noisy signals tend to have higher zero-crossing rate. In order to avoid small variations around zero caused by noise, a threshold around zero is given to consider a valid zerocrosing whenever the boundary is crossed. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "threshold" @default 0 @type "int/float" @description "the threshold which will be taken as the zero axis in both positive and negative sign.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "zerocrossingrate descriptor" @type "llll")
);

## ------------------------------------------------------------

strongdecay = ( -> BP_ESSENTIA_WRAPPER_FUNC(@name "strongdecay"));

$addref(
    @name "strongdecay"
    @description "Audio descriptor to compute the strong decay of a buffer. The strong decay is built from the non-linear combination of the signal energy and the signal temporal centroid, the latter being the balance of the absolute value of the signal. A signal containing a temporal centroid near its start boundary and a strong energy is said to have a strong decay. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "strongdecay descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## harmonicpeaks = (
##     $maxharmonics = 20,
##     $tolerance = 0.2,
##     $mode = 0 -> (
##         BP_ESSENTIA_WRAPPER_FUNC(
##             @name "harmonicpeaks" 
##             @mode $mode
##             @settings (
##                 "@maxharmonics" $maxharmonics
##                 "@tolerance" $tolerance
##             )
##         )
##     )
## );

## ------------------------------------------------------------

spectrum = (
    $size = 2048,
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectrum" 
            @mode $mode
            @settings "@size" $size
        )
    )
);

$addref(
    @name "spectrum"
    @description "Audio descriptor to compute the magnitude spectrum of a buffer. The resulting magnitude spectrum has a size which is half the size of the input array plus one. Bins contain raw (linear) magnitude values. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectrum descriptor" @type "llll")
);

## ------------------------------------------------------------

rhythm = (
    $maxtempo = 208,
    $mintempo = 40,
    $method = 'multifeature' -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "rhythmextractor2013" 
            @settings (
                "@maxtempo" $maxtempo
                "@method" $method
                "@mintempo" $mintempo
            )
            @output (
                "rhythm_bpm"
                "rhythm_ticks"
                "rhythm_estimates"
                "rhythm_intervals"
            )
        )
    )
);

$addref(
    @name "rhythm"
    @description "Audio descriptor for extract the beat positions and estimate their confidence as well as tempo in bpm for a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "rhythm_bpm" "rhythm_ticks" "rhythm_estimates" "rhythm_intervals"
    @arguments (
        $addarg(@name "maxtempo" @default 208 @type "int", @description "fastest tempo to detect, between 60 and 250.")
        $addarg(@name "mintempo" @default 40 @type "int", @description "slowest tempo to detect, between 40 and 180.")
        $addarg(@name "method" @default "'multifeature'" @type "symbol", @description "method used for beat tracking." @options
            $addopt(@value "'degara'" @description "degara" "method")
            $addopt(@value "'multifeature'" @description "multifeature" "method")
        )
    )
    @output $addout(@description "rhythm descriptor" @type "llll")
);

## ------------------------------------------------------------

logattack = ( -> BP_ESSENTIA_WRAPPER_FUNC(
        @name "logattacktime"
        @output (
            "logattack"
            "logattack_start"
            "logattack_stop"
        )
    )
);

$addref(
    @name "logattack"
    @description "Audio descriptor to compute the log (base 10) of the attack time of buffer's envelope. The attack time is defined as the time duration from when the sound becomes perceptually audible to when it reaches its maximum intensity. By default, the start of the attack is estimated as the point where the signal envelope reaches 20% of its maximum value in order to account for possible noise presence. Also by default, the end of the attack is estimated as as the point where the signal envelope has reached 90% of its maximum value, in order to account for the possibility that the max value occurres after the log-attack, as in trumpet sounds. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "logattack" "logattack_start" "logattack_stop"
    @output $addout(@description "logattack descriptor" @type "llll")
);

## ------------------------------------------------------------

chordsdetection = (
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "chordsdetection"
            @mode $mode
            @modes 0...2
        )
    )
);

$addref(
    @name "chordsdetection"
    @description "Audio descriptor to perform chord estimation on a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "chordsdetection descriptor" @type "llll")
);

## ------------------------------------------------------------

pitchmelodia = (
    $binresolution = 10,
    $filteriterations = 3,
    $framesize = 2048,
    $guessunvoiced = 0,
    $harmonicweight = 0.8,
    $hopsize = 1024,
    $magnitudecompression = 1,
    $magnitudethreshold = 40,
    $maxfrequency = 20000,
    $minduration = 50,
    $minfrequency = 40,
    $numberharmonics = 20,
    $peakdistributionthreshold = 0.9,
    $peakframethreshold = 0.9,
    $pitchcontinuity = 27.5625,
    $referencefrequency = 55,
    $samplerate = 44100,
    $timecontinuity = 100,
    $polyphonic = 0,
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name (if $polyphonic == 0 then "pitchmelodia" else "predominantpitchmelodia")
            @output "pitchmelodia" "pitchmelodia_confidence"
            @settings (
                "@binresolution" $binresolution
                "@filteriterations" $filteriterations
                "@framesize" $framesize
                "@guessunvoiced" $guessunvoiced
                "@harmonicweight" $harmonicweight
                "@hopsize" $hopsize
                "@magnitudecompression" $magnitudecompression
                "@magnitudethreshold" $magnitudethreshold
                "@maxfrequency" $maxfrequency
                "@minduration" $minduration
                "@minfrequency" $minfrequency
                "@numberharmonics" $numberharmonics
                "@peakdistributionthreshold" $peakdistributionthreshold
                "@peakframethreshold" $peakframethreshold
                "@pitchcontinuity" $pitchcontinuity
                "@referencefrequency" $referencefrequency
                "@samplerate" $samplerate
                "@timecontinuity" $timecontinuity
            )
            @mode $mode
        )
    )
);

$addref(
    @name "pitchmelodia"
    @description "Audio descriptor to estimate the fundamental frequency corresponding to the melody of a monophonic music signal based on the MELODIA algorithm. While the algorithm is originally designed to extract the predominant melody from polyphonic music, this implementation is adapted for monophonic signals. The approach is based on the creation and characterization of pitch contours, time continuous sequences of pitch candidates grouped using auditory streaming cues. It is strongly advised to use the default parameter values which are optimized for this task, except for @minfrequency and @maxfrequency, which will be context-dependent. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "pitchmelodia" "pitchmelodia_confidence"
    @arguments (
        $addarg(@name "binresolution" @default 10 @type "int" @description "salience function bin resolution, in cents.")
        $addarg(@name "filteriterations" @default 3 @type "int" @description "number of iterations for the octave errors / pitch outlier filtering process.")
        $addarg(@name "framesize" @default 2048 @type "int" @description "frame size for computing pitch salience.")
        $addarg(@name "guessunvoiced" @default 0 @type "int" @description "estimate pitch for non-voiced segments." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "harmonicweight" @default 0.8 @type "int/float" @description "weight decay ratio between two consequent harmonics. Use 1 for no decay.")
        $addarg(@name "hopsize" @default 1024 @type "int" @description "hop size with which the pitch salience function was computed.")
        $addarg(@name "magnitudecompression" @default 1 @type "int" @description "magnitude compression parameter for the salience function." @options
            $addopt(@value 0 @description "maximum compression")
            $addopt(@value 1 @description "no compression")
        )
        $addarg(@name "magnitudethreshold" @default 40 @type "int" @description "spectral peak magnitude threshold, in decibels.")
        $addarg(@name "maxfrequency" @default 20000 @type "int/float" @description "the maximum allowed frequency for salience function peaks.")
        $addarg(@name "minduration" @default 100 @type "int" @description "the minimum allowed contour duration.")
        $addarg(@name "minfrequency" @default 40 @type "int/float" @description "the minimum allowed frequency for salience function peaks.")
        $addarg(@name "numberharmonics" @default 20 @type "int" @description "number of considered harmonics.")
        $addarg(@name "peakdistributionthreshold" @default 0.9 @type "int/float" @description "allowed deviation below the peak salience mean over all frames.")
        $addarg(@name "peakframethreshold" @default 0.9 @type "int/float" @description "per-frame salience threshold factor.")
        $addarg(@name "pitchcontinuity" @default 27.5625 @type "int/float" @description "maximum allowed pitch change during 1 ms time period, in cents.")
        $addarg(@name "referencefrequency" @default 55 @type "int/float" @description "the reference frequency to cent conversion corresponding to the 0th cent bin.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "the sampling rate of the audio signal.")
        $addarg(@name "timecontinuity" @default 100 @type "int" @description "maximum allowed gap duration for a pitch contour, in milliseconds.")
        $addarg(@name "polyphonic" @default 0 @type "int" @description "optimize for polyphonic buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "voicevibrato" @default 0 @type 'int' @description "detect voice vibrato, when @polyphonic is 1." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "voicingtolerance" @default 0.2 @type 'int/float' @description "voicing tolerance between -1 and 1.4, when @polyphonic is 1.")
        $addarg(@name "mode" @default 0 @type "int" @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "pitchmelodia descriptor" @type "llll")
);

## ------------------------------------------------------------

mfcc = (
    $dcttype = 2,
    $highfrequencybound = 11000,
    $inputsize = 1025,
    $liftering = 0,
    $logtype = 'dbamp',
    $lowfrequencybound = 0,
    $normalize = 'unit_sum',
    $numberbands = 40,
    $numbercoefficients = 13,
    $samplerate = 44100,
    $silencethreshold = 1e-10,
    $type = 'power',
    $warpingformula = 'htkmel',
    $weighting = 'warping',
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "mfcc"
            @settings (      
                "@dcttype" $dcttype
                "@highfrequencybound" $highfrequencybound
                "@inputsize" $inputsize
                "@liftering" $liftering
                "@logtype" $logtype
                "@lowfrequencybound" $lowfrequencybound
                "@normalize" $normalize
                "@numberbands" $numberbands
                "@numbercoefficients" $numbercoefficients
                "@samplerate" $samplerate
                "@silencethreshold" $silencethreshold
                "@type" $type
                "@warpingformula" $warpingformula
                "@weighting" $weighting
            )
            @output "mfcc_bands" "mfcc"
            @mode $mode
        )
    )
);

$addref(
    @name "mfcc"
    @description "Audio descriptor to compute the mel-frequency cepstrum coefficients of a buffer's spectrum. As there is no standard implementation, the MFCC-FB40 is used by default. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "mfcc_bands" "mfcc"
    @arguments (
        $addarg(@name "dcttype" @default 2 @type "int" @description "DCT type.")
        $addarg(@name "highfrequencybound" @default 11000 @type "int/float" @description "upper bound of the frequency range, in Hz.")
        $addarg(@name "inputsize" @default 1025 @type "int" @description "size of input spectrum.")
        $addarg(@name "liftering" @default 0 @type "int" @description "liftering coefficient. Use '0' to bypass it.")
        $addarg(@name "logtype" @default "'dbamp'" @type "symbol" @description "logarithmic compression type." @options 
            $addopt(@value "'natural'")
            $addopt(@value "'dbpow'")
            $addopt(@value "'dbamp'")
            $addopt(@value "'log'")
        )
        $addarg(@name "lowfrequencybound" @default 0 @type "float" @description "lower bound of the frequency range, in Hz.")
        $addarg(@name "normalize" @default "'unit_sum'" @type "symbol" @description "spectrum bin weights to use for each mel band." @options 
            $addopt(@value "'unit_sum'")
            $addopt(@value "'unit_tri'")
            $addopt(@value "'unit_max'")
        )
        $addarg(@name "numberbands" @default 40 @type "int" @description "number of mel-bands in the filter.")
        $addarg(@name "numbercoefficients" @default 13 @type "int" @description "number of output mel coefficients.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal, in Hz.")
        $addarg(@name "silencethreshold" @default 1e-10 @type "int/float" @description "silence threshold for computing log-energy bands.")
        $addarg(@name "type" @default "'power'" @type "symbol" @description "use magnitude or power spectrum." @options 
            $addopt(@value "'magnitude'")
            $addopt(@value "'power'")
        )
        $addarg(@name "warpingformula" @default "'htkmel'" @type "symbol" @description "scale implementation type." @options 
            $addopt(@value "'slaneymel'")
            $addopt(@value "'htkmel'")
        )
        $addarg(@name "weighting" @default "'warping'" @type "symbol" @description "type of weighting function for determining triangle area." @options
            $addopt(@value "'warping'")
            $addopt(@value "'linear'")
        )
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "mfcc descriptor" @type "llll")
);

## ------------------------------------------------------------

flux = (
    $halfrectify = 0,
    $norm = "L2",
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "flux"
            @settings (
                "@halfrectify" $halfrectify
                "@norm" $norm
            )
            @mode $mode
        )
    )
);

$addref(
    @name "flux"
    @description "Audio descriptor to compute the spectral flux of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "halfrectify" @default 0 @type "int", @description "half-rectify the differences in each spectrum bin." @options
            BP_REF_SWITCH_OPTIONS    
        )
        $addarg(@name "norm" @default "'L2'" @type "symbol", @description "norm to use for difference computation." @options 
            $addopt(@value "'L1'" @description "L1 norm")
            $addopt(@value "'L2'" @description "L2 norm")
        )
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "flux descriptor" @type "llll")
);

## ------------------------------------------------------------

larm = (
    $attacktime = 10,
    $power = 1.5,
    $releasetime = 1500,
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "larm"
            @mode $mode
        )
    )
);

$addref(
    @name "larm"
    @description "Audio descriptor to estimate the long-term loudness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "attacktime" @default 10 @type "int" @description "attack time of the first order lowpass in the attack phase.")
        $addarg(@name "power" @default 1.5 @type "int/float" @description "power used for averaging.")
        $addarg(@name "releasetime" @default 1500 @type "int" @description "release time of the first order lowpass in the release phase.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "larm descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralcentroid = (
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralcentroid"
            @mode $mode
        )
    )
);

$addref(
    @name "spectralcentroid"
    @description "Audio descriptor to calculate the spectral centroid of a buffer, defined as the 'center of mass' of the spectrum, in Hertz. Perceptually, it has a robust connection with the impression of 'brightness' of a sound, and therefore is used to characterize musical timbre. It is calculated as the weighted mean of the frequencies present in the signal, with their magnitudes as the weights. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralcentroid descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalcentroid = ( 
    -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "temporalcentroid"
        )
    )
);

$addref(
    @name "temporalcentroid"
    @description "Audio descriptor to calculate the temporal centroid of a buffer, defined as the point in time that is a temporal balancing point of the sound's energy. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
    )
    @output $addout(@description "temporalcentroid descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralflatness = (
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "spectralflatness"
            @mode $mode
        )
    )
);

$addref(
    @name "spectralflatness"
    @description "Audio descriptor to calculate the spectral flatness of a buffer, defined as the ratio between the spectrum's geometric mean and arithmetic mean. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "spectralflatness descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalflatness = ( 
    -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "temporalflatness"
        )
    )
);

$addref(
    @name "temporalflatness"
    @description "Audio descriptor to calculate the temporal flatness of a buffer, defined as the ratio between the buffer envelope's geometric mean and arithmetic mean. Flatness is undefined for empty input and negative values, therefore an exception is thrown in any both cases. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
    )
    @output $addout(@description "temporalflatness descriptor" @type "llll")
);

## ## ------------------------------------------------------------
## BUGGY DESCRIPTOR

## spectralcontrast = (
##     $framesize = 2048,
##     $highfrequencybound = 11000,
##     $lowfrequencybound = 20,
##     $neighbourratio = 0.4,
##     $numberbands = 6,
##     $samplerate = 22050,
##     $staticdistribution = 0.15,
##     $mode = 0 -> ( 
##         BP_ESSENTIA_WRAPPER_FUNC(
##             @name "spectralcontrast"
##             @mode $mode
##             @settings (
##                 "@framesize" $framesize
##                 "@highfrequencybound" $highfrequencybound
##                 "@lowfrequencybound" $lowfrequencybound
##                 "@neighbourratio" $neighbourratio
##                 "@numberbands" $numberbands
##                 "@samplerate" $samplerate
##                 "@staticdistribution" $staticdistribution
##             )
##             @output "spectralcontrast" "spectralvalley"
##         )
##     )
## );

## $addref(
##     @name "spectralcontrast"
##     @description "Audio descriptor to calculate the spectral contrast of a buffer. See #analyze."
##     @category BP_REF_LABEL_ANALYSIS
##     @arguments (
##         $addarg(@name "framesize" @default 2048 @type "int" @description "size of the fft frames.")
##         $addarg(@name "highfrequencybound" @default 11000 @type "int" @description "upper bound of the highest band.")
##         $addarg(@name "lowfrequencybound" @default 20 @type "int" @description "lower bound of the lowest band.")
##         $addarg(@name "neighbourratio" @default "0.4" @type "int/float" @description "ratio of the bins in the sub band used to calculate the peak and valley.")
##         $addarg(@name "numberbands" @default 6 @type "int" @description "number of bands in the filter.")
##         $addarg(@name "samplerate" @default 22050 @type "int" @description "sampling rate.")
##         $addarg(@name "staticdistribution" @default "0.15" @type "int/float" @description "ratio of the bins to distribute equally.")
##         $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
##             BP_REF_ESSENTIA_ANALYSIS_OPTIONS
##         )
##     )
##     @output $addout(@description "spectralcontrast descriptor" @type "llll")
## );

## ------------------------------------------------------------

barkbands = (
    $numberbands = 27,
    $samplerate = 44100,
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "barkbands"
            @settings (
                "@numberbands" $numberbands
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

$addref(
    @name "barkbands"
    @description "Audio descriptor to compute the Bark bands of a spectrum. For each bark band the power-spectrum — i.e., mag-squared — is summed. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "numberbands" @default 27 @type "int" @description "number of desired barkbands.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "barkbands descriptor" @type "llll")
);

## ------------------------------------------------------------

beatsloudness = (
    $beats,
    $beatduration = 0.05,
    $beatwindowduration = 0.1,
    $frequencybands = 20 150 400 3200 7000 22000,
    $samplerate = 44100 -> (
        if $beats == null then printerror("you must provide a value for @beats in beatsloudness().");
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "beatsloudness"
            @settings (
                "@beats" $beats
                "@beatduration" $beatduration
                "@beatwindowduration" $beatwindowduration
                "@frequencybands" $frequencybands
                "@samplerate" $samplerate
            )
            @output "beatsloudness" "beatsloudness_bandratio"
        )
    )
);

$addref(
    @name "beatsloudness"
    @description "Audio descriptor to compute the spectrum energy of beats in an audio signal given their positions. The energy is computed both on the whole frequency range and for each of the specified frequency bands. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "beatsloudness" "beatsloudness_bandratio"
    @arguments (
        $addarg(@name "beats" @type "list" @description "duration of the window in which the beat will be restricted.")
        $addarg(@name "beatduration" @type "int/float" @default 0.05 @description "duration of the window in which to look for the beginning of the beat, centered around the values in @beats.")
        $addarg(@name "beatwindowduration" @type "int/float" @default 0.1 @description "list of beat positions.")
        $addarg(@name "frequencybands"  @type "list" @default 20 150 400 3200 7000 22000 @description "list of bands to compute energy ratios.")
        $addarg(@name "samplerate" @type "int"  @default 44100 @description "audio sampling rate.")
        $addarg(@name "mode" @type "int" @default 0 @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "beatsloudness descriptor" @type "llll")
);

## ------------------------------------------------------------

bfcc = (
    $dcttype = 2,
    $highfrequencybound = 11000,
    $inputsize = 1025,
    $liftering = 0,
    $logtype = 'dbamp',
    $lowfrequencybound = 0,
    $normalize = "unit_sum",
    $numberbands = 40,
    $numbercoefficients = 13,
    $samplerate = 44100,
    $type = 'power',
    $weighting = 'warping',
    $mode = 0 -> (
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "bfcc"
            @settings (
                "@dcttype" $dcttype
                "@highfrequencybound" $highfrequencybound
                "@inputsize" $inputsize
                "@liftering" $liftering
                "@logtype" $logtype
                "@lowfrequencybound" $lowfrequencybound
                "@numberbands" $numberbands
                "@numbercoefficients" $numbercoefficients
                "@samplerate" $samplerate
                "@type" $type
                "@weighting" $weighting
                "@mode" $mode
            )
            @output "bfcc_bands" "bfcc"
        )
    )
);

$addref(
    @name "bfcc"
    @description "Audio descriptor to compute the bark-frequency cepstrum coefficients of a spectrum. Bark bands and their subsequent usage in cepstral analysis have shown to be useful in percussive content. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "bfcc_bands" "bfcc"
    @arguments (
        $addarg(@name "dcttype" @default 2 @type "int" @description "DCT type.")
        $addarg(@name "highfrequencybound" @default 11000 @type "int/float" @description "upper bound of the frequency range.")
        $addarg(@name "inputsize" @default 1025 @type "int" @description "size of input spectrum.")
        $addarg(@name "liftering" @default 0 @type "int" @description "liftering coefficient. Use 0 to bypass it.")
        $addarg(@name "logtype" @default "'dbamp'" @type "int" @description "logarithmic compression type." @options 
            $addopt(@value "'dbpow'" @description "Use if working with power.")
            $addopt(@value "'dbamp'" @description "Use if working with magnitudes.")
        )
        $addarg(@name "lowfrequencybound" @default 0 @type "int" @description "lower bound of the frequency range.")
        $addarg(@name "normalize" @default "'unit_sum'" @type "int" @description "normalization mode" @options 
            $addopt(@value "'unit_max'" @description "makes the vertex of all the triangles equal to 1.")
            $addopt(@value "'unit_sum'" @description "makes the area of all the triangles equal to 1.")
        )
        $addarg(@name "numberbands" @default 40 @type "int" @description "number of bark bands in the filter.")
        $addarg(@name "numbercoefficients" @default 13 @type "int" @description "number of output cepstrum coefficients.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal.")
        $addarg(@name "type" @default "'power'" @type "int" @description "magnitude or power spectrum." @options 
            $addopt(@value "'power'")
            $addopt(@value "'magnitude'")
        )
        $addarg(@name "weighting" @default "'warping'" @type "int" @description "type of weighting function for determining triangle area." @options 
            $addopt(@value "'warping'")
            $addopt(@value "'linear'")
        )
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "bfcc descriptor" @type "llll")
);

## ------------------------------------------------------------

rolloff = (
    $cutoff = 0.85,
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "rolloff"
            @settings (
                "@cutoff" $cutoff
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

$addref(
    @name "rolloff"
    @description "Audio descriptor to compute the roll-off frequency of a spectrum. The roll-off frequency is defined as the frequency under which some percentage — i.e., cutoff — of the total energy of the spectrum is contained. The roll-off frequency can be used to distinguish between harmonic — i.e., below roll-off — and noisy sounds — i.e., above roll-off. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "cutoff" @default 0.85 @type "float" @description "the ratio of total energy to attain before yielding the roll-off frequency.")
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "rolloff descriptor" @type "llll")
);

## ------------------------------------------------------------

maxmagfreq = (
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "maxmagfreq"
            @settings (
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

$addref(
    @name "maxmagfreq"
    @description "Audio descriptor to compute the frequency with the largest magnitude in a spectrum. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "maxmagfreq descriptor" @type "llll")
);

## ------------------------------------------------------------

onsets = (
    $alpha = 0.1,
    $delay = 5,
    $framerate = 86.1328,
    $silencethreshold = 0.02 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "onsets"
            @settings (
                "@alpha" $alpha
                "@delay" $delay
                "@framerate" $framerate
                "@silencethreshold" $silencethreshold
            )
        )
    )
);

$addref(
    @name "onsets"
    @description "Audio descriptor to compute the onset positions in a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "alpha" @default 0.1 @type "float" @description "proportion of the mean included to reject smaller peaks — filters very short onsets.")
        $addarg(@name "delay" @default 5 @type "int" @description "number of frames used to compute the threshold — size of short-onset filter.")
        $addarg(@name "framerate" @default 86.1328 @type "float" @description "frames per second.")
        $addarg(@name "silencethreshold" @default 0.02 @type "float" @description "threshold for silence.")
    )
    @output $addout(@description "onsets descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## onsetrate = (
##     -> ( 
##         BP_ESSENTIA_WRAPPER_FUNC(
##             @name "onsetrate"
##         )
##     )
## );

## $addref(
##     @name "onsetrate"
##     @description "Audio descriptor to compute the number of onsets per second and their position in time for an audio signal. Onset detection functions are computed using both high frequency content and complex-domain methods available in #onsetdetection. Please note that due to a dependence on #onsets, this descriptor is only valid for audio signals with a sampling rate of 44100 Hz. See #analyze."
##     @category BP_REF_LABEL_ANALYSIS
##     @output $addout(@description "onsetrate descriptor" @type "llll")
## );

## ------------------------------------------------------------

onsetdetection = (
    $method = "hfc",
    $samplerate = 44100,
    $mode = 1 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "onsetdetection"
            @mode $mode
            @modes 1...3
            @settings (
                "@method" $method
                "@samplerate" $samplerate
            )
        )
    )
);

$addref(
    @name "onsetdetection"
    @description "Audio descriptor to compute buffer onsets, given various onset detection functions. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        $addarg(@name "method" @default "'hfc'" @description "the method used for onset detection." @options 
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        $addarg(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        $addarg(@name "mode" @default 1 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "onsetdetection descriptor" @type "llll")
);

## ------------------------------------------------------------

tonalkey = (
    $numharmonics = 4,
    $pcpsize = 36,
    $profiletype = 'bgate',
    $slope = 0.6,
    $usemajmin = 0,
    $usepolyphony = 1,
    $usethreechords = 1,
    $mode = 0 -> ( 
        BP_ESSENTIA_WRAPPER_FUNC(
            @name "key"
            @settings (
                "@numharmonics" $numharmonics
                "@pcpsize" $pcpsize
                "@profiletype" $profiletype
                "@slope" $slope
                "@usemajmin" $usemajmin
                "@usepolyphony" $usepolyphony
                "@usethreechords" $usethreechords
            )
            @mode $mode
            @modes 0...2
        )
    )
);

$addref(
    @name "tonalkey"
    @description "Audio descriptor to perform tonal key signature estimation on a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        $addarg(@name "numharmonics" @default 4 @type "int" @description "number of harmonics that should contribute to the polyphonic profile.")
        $addarg(@name "pcpsize" @default 36 @type "int" @description "pitch class profile size.")
        $addarg(@name "profiletype" @default "'bgate'" @description "the type of polyphic profile to use for correlation calculation." @options
            $addopt(@value "'diatonic'" @description "binary profile with diatonic notes of both modes.")
            $addopt(@value "'tonic triad'" @description "just the notes of the major and minor chords. exclusively for testing.")
            $addopt(@value "'krumhansl'" @description "reference key profiles based on cognitive experiments — useful for pop music.")
            $addopt(@value "'temperley'" @description "key profiles extracted from corpus analysis of euroclassical music, especially in minor keys.")
            $addopt(@value "'shaath'" @description "profiles based on Krumhansl's specifically tuned to popular and electronic music.")
            $addopt(@value "'noland'" @description "profiles from Bach's 'Well Tempered Klavier'.")
            $addopt(@value "'edma'" @description "automatic profiles extracted from corpus analysis of EDM — better than Shaath's")
            $addopt(@value "'edmm'" @description "same as edma, but manually tweaked according to heuristic observation.")
            $addopt(@value "'braw'" @description "profiles obtained by calculating the median profile for each mode from a subset of BeatPort dataset.")
            $addopt(@value "'bgate'" @description "same as braw but zeroing the 4 less relevant elements of each profile.")
        )
        $addarg(@name "slope" @default 0.6 @type "int/float" @description "value of the slope of the exponential harmonic contribution to the polyphonic profile.")
        $addarg(@name "usemajmin" @default 0  @type "int" @description "use a third profile called 'majmin' for ambiguous tracks. Only avalable for the edma, bgate and braw profiles." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "usepolyphony" @default 1 @type "int"  @description "enables the use of polyphonic profiles to define key profiles — this includes the contributions from triads as well as pitch harmonics." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "usethreechords" @default 1 @type "int"  @description "consider only the 3 main triad chords of the key — i.e., T, D, SD — to build the polyphonic profiles." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output $addout(@description "tonalkey descriptor" @type "llll")
);

## ------------------------------------------------------------

process = (
    $buffer, 
    $commands, 
    $prefade = 0,
    $keepkeys = null -> (
        if $buffer == null then (
            printerror("attempt to pass null value as @buffer in process()")
        );
        if $commands == null then (
            printerror("you must provide audio processing commands in process()")
        );
        $source = $buffer.getkey("source");
        if $source == null then printerror("attempt to process invalid buffer in process():" $buffer);
        $offset = $buffer.getkey("offset");
        $duration = $buffer.getkey("duration");
        $crop = $offset != 0 || $duration != $buffer.getkey("source_end");
        BP_DISPATCH_FUNC("process",
            [ "source" $source ]
            [ "process" 
                (if $crop then crop(@start $offset, @end $offset + $duration))
                ($prefade &&& $prefade > 0 &&& fade(@fadein $prefade, @fadeout $prefade))
                $commands 
            ]
        );
        $extrakeys = for $k in thin($keepkeys) collect (
            $val = $buffer.getkey($k);
            $val &&& [ $k $val ]
        );
        for $buf in BP_TMP_BUFF collect BP_NEWBUFF_FUNC(
            @source $buf
            @pitch $buffer.getkey("pitch") 
            @extras $extrakeys
        )
    )
);

$addref(
    @name "process",
    @description "Applies a sequence of DSP operations to the input buffer, prior to rendering, via audio processing commands. These commands are generated through functions (e.g., see #reverse, #paulstretch, #freeverb, #rubberband), which contain the parameters for that specific DSP operation. This results in a newly created buffer, with updated keys. To keep keys from the input buffer, such as keys associated with previous feature analyses, use the @keepkeys argument by passing an optional list of keys. See @process argument in #render.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "buffer", @type "llll", @description "buffer to process.")
        $addarg(@name "commands", @type "llll", @description "list of audio process commands.")
        $addarg(@name "prefade", @default 0 @type "llll/null", @description "optional pre-fade amount, in milliseconds.")
        $addarg(@name "keepkeys", @default "null" @type "symbol/list/null", @description "optional list of keys to keep from input buffer.")
    ),
    @output $addout(@description "processed buffer" @type "llll")
);


## ------------------------------------------------------------

fade = (
    $fadein = 5, 
    $fadeout = 5,
    $fadeincurve = -0.25,
    $fadeoutcurve = 0.25,
    $fadeintype = 0,
    $fadeouttype = 0,
    $timeunit = 0 -> (
        [
            [ "fx" "fade" ]
            [ "params"
                [ "fadein" $fadein ]
                [ "fadeout" $fadeout ]
                [ "timeunit" $timeunit ]
                [ "fadeincurve" $fadeincurve ]
                [ "fadeoutcurve" $fadeoutcurve ]
                [ "fadeintype" $fadeintype + 1 ]
                [ "fadeouttype" $fadeouttype + 1 ]
            ]
        ]
    )
);

$addref(
    @name "fade",
    @description "Audio process command for applying fadein/fadeout to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "fadein", @default 5, @type "int/float", @description "fade-in duration.")
        $addarg(@name "fadeout", @default 5, @type "int/float", @description "fade-out duration.")
        $addarg(@name "fadeintype", @default 0, @type "int", @description "fade-in type.", @options 
            BP_REF_CURVE_OPTIONS
        )
        $addarg(@name "fadeouttype",@default 0, @type "int", @description "fade-out type.", @options 
            BP_REF_CURVE_OPTIONS
        )
        $addarg(@name "fadeincurve", @default -0.25, @type "int/float", @description "fade-in curve amount, between -1 and 1.")
        $addarg(@name "fadeoutcurve", @default 0.25, @type "int/float", @description "fade-out curve amount, between -1 and 1.")
        $addarg(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "fade command" @type "llll")
);

## ------------------------------------------------------------

crop = (
    $start = 0,
    $end = 1000,
    $timeunit = 0 -> (
        if $end == null || $start == null then printerror("you must provide values for @start and @end in crop()");
        if $end <= $start then printerror("@end must be greater than @start in crop()");
        [
            ["fx" "crop"]
            ["params" 
                [ "timeunit" $timeunit ]
                [ "start" $start ]
                [ "end" $end ]
            ]
        ]
    )
);

$addref(
    @name "crop",
    @description "Audio process command for cropping a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "start" @default 0 @type "int/float", @description "start time.")
        $addarg(@name "end" @default 1000 @type "int/float", @description "end time.")
        $addarg(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "crop command" @type "llll")
);

## ------------------------------------------------------------

bpthru = ( -> [ [ "fx" "thru" ] ]);

## ------------------------------------------------------------

reverse = ( -> [ [ "fx" "reverse" ] ]);

$addref(
    @name "reverse",
    @description "Audio process command for reversing a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output $addout(@description "reverse command" @type "llll")
);

## ------------------------------------------------------------

dcfilter = ( -> [ [ "fx" "dcfilter" ] ]);

$addref(
    @name "dcfilter",
    @description "Audio process command for removing DC offset from a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output $addout(@description "dcfilter command" @type "llll")
);

## ------------------------------------------------------------

getchannels = (
    $buffer, 
    $channels = null,
    $all = 1 -> (
        $buffer.process(
            [
                [ "fx" "channel" ]
                [ "params"
                    [ "all" $all ]
                    [ "channels" $channels ]
                ]
            ]
        )    
    )
);

$addref(
    @name "getchannels",
    @description "Extracts one or more buffer channels as individual buffers.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "buffer", @type "llll", @description "buffer to extract channels from.")
        $addarg(@name "channels" @default "null" @type "int/list/llll/null", @description "number to channels to extract — ignored when @all is 1.")
        $addarg(@name "all" @default 1 @type "int", @description "extract all channels." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "channels as buffers", @type "llll")
);

## ------------------------------------------------------------

freeverb = (
    $roomsize = .5,
    $damp = .5,
    $width = .5,
    $tail = -1,
    $dry = 1., 
    $wet = 1/6. -> (
        [
            ["fx" "freeverb"]
            [ "params" 
                [ "roomsize" $roomsize ]
                [ "damp" $damp ]
                [ "width" $width ]
                [ "tail" $tail ]
                [ "dry" if depth($dry) > 1 || length($dry) > 1 then [ bpf($dry) ] else $dry ]
                [ "wet" if depth($wet) > 1 || length($wet) > 1 then [ bpf($wet) ] else $wet ]
            ]
        ]
    )
);

$addref(
    @name "freeverb",
    @description "Audio process command for applying reverb to a buffer. See #process function.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "roomsize", @default 0.5, @type "int/float", @description "reverb room size")
        $addarg(@name "damp", @default 0.5, @type "int/float", @description "damping coefficient")
        $addarg(@name "width", @default 0.5, @type "int/float", @description "panning width/spread, from 0 to 1.")
        $addarg(@name "tail", @default -1, @type "int/float", @description "duration of reverb tail in ms." @options 
            $addopt(@value -1 @description "auto")
            $addopt(@value 0 @description "no" "tail")
            $addopt(@value ">0" @description "duration" "in" "ms")
        )
        $addarg(@name "dry", @default 1, @type "int/float/llll", @description "amount of dry output, as either a single number or envelope.")
        $addarg(@name "wet", @default 0.16, @type "int/float/llll", @description "amount of wet output, as either a single number or envelope.")
    ),
    @output $addout(@description "freeverb command" @type "llll")
);

## ------------------------------------------------------------

BP_OSC_GEN_FUNC = (
    $name,
    $frequency = 440,
    $duration = 50,
    $params = null -> (
        $source = $frequency.getkey("source");
        $isnoise = $name == "noise";
        $salience = $isnoise == 0 && $source == null;
        ## if generator is noise
        if $isnoise == 1 then (
            $frequency = rand(40, 1500)
        ) else if $source == null then (
            ## if @frequency is an envelope
            $source = envelope($frequency, @duration $duration).getkey("source");
            if depth($frequency) > 1 || length($frequency) > 1 then (
                $frequency = trans(bpf($frequency))::(2 1)
            )
        ) else (
            ## if @frequency is a buffer
            $duration = $frequency.getkey("duration");
            $frequency = mc2f(6000)
        );
        BP_DISPATCH_FUNC("generate", 
            [
                [ "fx" $name ]
                [ "params" 
                    $params
                    if $isnoise == 1 then (
                        [ "tail" $duration ] 
                        [ "bang" ]
                    ) else (
                        [ $source ]
                    )
                ]
            ]
        );
        $pitch = f2mc($frequency);
        BP_NEWBUFF_FUNC(@source BP_TMP_BUFF @pitch $pitch)
    )
);

## ------------------------------------------------------------

noise = (
    $duration = 50 -> (
        BP_OSC_GEN_FUNC("noise", @duration $duration)
    )
);

$addref(
    @name "noise",
    @description "Generates white noise as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

randosc = (
    $frequency = 440,
    $duration = 50 -> (
        BP_OSC_GEN_FUNC("rand", @frequency $frequency @duration $duration)
    )
);

$addref(
    @name "randosc",
    @description "Generates a random oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

cycle = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0.25 -> (
        BP_OSC_GEN_FUNC("cycle", @frequency $frequency, @duration $duration, @params [ "phase" float($phase) ])
    )
);

$addref(
    @name "cycle",
    @description "Generates a sinusoidal oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        $addarg(@name "phase", @default 0.5, @type "int/float", @description "initial phase, in the 0–1 range.")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

rect = (
    $frequency = 440, 
    $duration = 50,
    $duty = 0.5 -> (
        BP_OSC_GEN_FUNC("rect", @frequency $frequency, @duration $duration, @params [ "duty" $duty ])
    )
);

$addref(
    @name "rect",
    @description "Generates a bipolar, anti-aliased rectangular (pulse) oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        $addarg(@name "duty", @default 0.5, @type "int/float/llll", @description "duty cycle in the range of 0-1, either as a number, envelope, or buffer.")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

saw = (
    $frequency = 440, 
    $duration = 50 -> (
        BP_OSC_GEN_FUNC("saw", @frequency $frequency, @duration $duration)
    )
);

$addref(
    @name "saw",
    @description "Generates a bipolar, anti-aliased sawtooth oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

tri = (
    $frequency = 440, 
    $duration = 50,
    $duty = 0.5 -> (
        BP_OSC_GEN_FUNC("tri", @frequency $frequency, @duration $duration, @params [ "duty" $duty ])
    )
);

$addref(
    @name "tri",
    @description "Generates a bipolar, anti-aliased triangular oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        $addarg(@name "duty", @default 0.5, @type "int/float/llll", @description "duty cycle in the range of 0-1, either as a number, envelope, or buffer.")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

triangle = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0,
    $offset = 0.5 -> (
        BP_OSC_GEN_FUNC("triangle", @frequency phasor($frequency, @duration $duration @phase $phase), @duration $duration @params [ "phase" float($offset) ])
    )
);

$addref(
    @name "triangle",
    @description "Generates a triangular/ramp oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        $addarg(@name "phase", @default 0, @type "int/float", @description "initial phase, in the 0-1 range.")
        $addarg(@name "offset", @default 0.5, @type "int/float", @description "peak position offset, in the 0-1 range.")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

phasor = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0. -> (
        BP_OSC_GEN_FUNC("phasor", @frequency $frequency, @duration $duration, @params [ "phase" float($phase) ])
    )
);

$addref(
    @name "phasor",
    @description "Generates a unipolar ramp oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        $addarg(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        $addarg(@name "phase", @default 0, @type "int/float", @description "initial phase, in the 0-1 range.")
    ),
    @output $addout(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

envelope = (
    $envelope = 0, 
    $duration = 1000 -> (
        $depth = depth($envelope);
        $length = length($envelope);
        if $depth > 1 || $length > 1 then ($envelope = [ bpf($envelope) ]);
        BP_DISPATCH_FUNC("generate", 
            [
                [ "fx" "envelope"]
                [ "params" 
                    [ "duration" $duration ]
                    [ $envelope ]
                ]
            ]
        );
        BP_NEWBUFF_FUNC(@source BP_TMP_BUFF)
    )
);

$addref(
    @name "envelope",
    @description "Generates an audio envelope as a buffer, given a single number or a breakpoint function.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "envelope", @default 0, @type "int/float/llll", @description "envelope, as either a single number or a breakpoint function.")
        $addarg(@name "duration", @default 1000, @type "int", @description "envelope duration, in milliseconds")
    ),
    @output $addout(@description "envelope" @type "llll")
);

## ------------------------------------------------------------

clicks = (
    $onsets = 0, 
    $gains = 1,
    $impulse = 1,
    $ampunit = 0,
    $timeunit = 0 -> (
        for $x in ["onsets" $onsets] [ "gains" $gains ] [ "impulse" $impulse ] do (
            $k = $x::(1 2);
            if $k == null || $k.length() > 1  then (
                printerror($x::(1 1) "must be a flat list")
            )
        );
        BP_DISPATCH_FUNC("generate", 
            [
                [ "fx" "clicks"]
                [ "params" 
                    [ "impulse" $impulse ]
                    [ "gains" $gains ]
                    [ "onsets" $onsets.max(1) ]
                ]
            ]
        );
        $buff = BP_NEWBUFF_FUNC(@source BP_TMP_BUFF);
        if $buff.getkey('duration') < 2 then (
            $buff.process(
                join(envelope(0 @duration 2))
            )
        ) else (
            $buff
        )
    )
);

$addref(
    @name "clicks",
    @description "Generates a buffer containing a set of clicks at specific onsets. Note that if the first onset value is 0, it might get silenced when the @fade argument in #render is non-zero.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "onsets" @default 0 @type "int/float/list" @description "onset positions.")
        $addarg(@name "gains" @default 1 @type "int/float/list" @description "click gains.")
        $addarg(@name "impulse" @default 1 @type "int/float/list" @description "impulse, a list of audio samples.")
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
    ),
    @output $addout(@description "clicks buffer" @type "llll")
);

## ------------------------------------------------------------

paulstretch = (
    $stretching = 1,
    $timeunit = 2,
    $envtimeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        [
            [ "fx" "paulstretch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "spectral" $spectral ] 
                [ "framesize" $framesize ] 
            ]
        ]
    )
);

$addref(
    @name "paulstretch",
    @description "Audio process command for applying time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options (
            BP_REF_TIMEUNIT_OPTIONS
        ))
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "spectral", @default 1, @type "int", @description "stretching mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulstretch command" @type "llll")
);

## ------------------------------------------------------------

paulfreeze = (
    $duration = 1000,
    $position = 0,
    $jitter = 0,
    $timeunit = 0,
    $spectral = 0,
    $framesize = 8192 -> (
        [
            [ "fx" "paulfreeze" ]
            [ "params" 
                [ "duration" $duration ||| 1000 ]
                [ "onset" [ $position $jitter ] ]
                [ "timeunit" $timeunit ]
                [ "spectral" $spectral ]
                [ "framesize" $framesize ]
            ]
        ]
    )
);

$addref(
    @name "paulfreeze",
    @description "Audio process command for freezing a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "duration" @default 1000 @type "int/float" @description "freezing duration, based on @timeunit.")
        $addarg(@name "position" @default 0 @type "int/float" @description "freezing time position")
        $addarg(@name "jitter" @default 0 @type "int/float" @description "variation around time position, in milliseconds. To use entire buffer, use 'all'.")
        $addarg(@name "timeunit" @default 0 @type "int" @description "time unit.", @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "spectral" @default 0 @type "int", @description "stretching mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulfreeze command" @type "llll")
);

## ------------------------------------------------------------

overdrive = (
    $factor = 1 -> (
        $factor = if depth($factor) > 1 || length($factor) > 1 then [ bpf($factor) ] else $factor;
        [
            [ "fx" "overdrive" ]
            [ "params" 
                [ "factor" $factor ]
            ]
        ]
    )
);

$addref(
    @name "overdrive",
    @description "Audio process command for applying soft-clip distortion to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "factor", @type "int/float/llll", @description "amplitude distortion factor, either as single number or envelope.")
    ),
    @output $addout(@description "overdrive command" @type "llll")
);

## ------------------------------------------------------------

window = (
    $wintype = "hann",
    $winnormalized = 0,
    $zeropadding = 0,
    $zerophase = 0 -> (
        [
            [ "fx" "window" ]
            [ "params" 
                [ "wintype" $wintype ]
                [ "winnormalized" $winnormalized ]
                [ "zeropadding" $zeropadding ]
                [ "zerophase" $zerophase ]
            ]
        ]
    )
);

$addref(
    @name "window",
    @description "Audio process command for applying a windowing function to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "wintype", @default "'hann'", @type "symbol", @description "window type, as a symbol" @options
            BP_REF_WINDOW_OPTIONS
        )
        $addarg(@name "winnormalized", @default 0, @type "int", @description "normalize window samples to sum up to 1 and multiply by a factor of 2." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "zeropadding", @default 0, @type "int", @description "number of samples for zero padding.")
        $addarg(@name "zerophase", @default 0, @type "int", @description "zero phase windowing" @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "window command" @type "llll")
);

## ------------------------------------------------------------

biquad = (
    $frequency = 2000,
    $type = 2,
    $gain = 1,
    $q = 100 -> (
        $frequency = $frequency.getkey("source") ||| [ bpf($frequency) ];
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        $q = $q.getkey("source") ||| [ bpf($q) ];
        if contains($type) == 16 then (
            $type = (
                [ "lowpass" 0 ]
                [ "highpass" 1 ]
                [ "bandpass" 2 ]
                [ "bandstop" 3 ]
                [ "peaknotch" 4 ]
                [ "lowshelf" 5 ]
                [ "highshelf" 6 ]
                [ "resonant" 7 ]
                [ "allpass" 8 ]
            ).$type
        );
        if $type == null then printerror("invalid value for @type in biquad().");
        [
            [ "fx" "biquad" ]
            [ "params" 
                [ "type" "edit_mode" $type + 1 ]
                [ "frequency" $frequency ]
                [ "gain" $gain ]
                [ "q" $q ]
            ]
        ]
    )
);

$addref(
    @name "biquad",
    @description "Audio process command for applying biquad filtering to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "type", @type "int/symbol", @description "filter type, as a symbol or integer." @options
            $addopt(@value 0 @description "lowpass")
            $addopt(@value 1 @description "highpass")
            $addopt(@value 2 @description "bandpass")
            $addopt(@value 3 @description "bandstop")
            $addopt(@value 4 @description "peaknotch")
            $addopt(@value 5 @description "lowshelf")
            $addopt(@value 6 @description "highshelf")
            $addopt(@value 7 @description "resonant")
            $addopt(@value 8 @description "allpass")
        )
        $addarg(@name "frequency", @default 2000, @type "int/float", @description "cutoff/center frequency.")
        $addarg(@name "gain", @default 1, @type "int/float", @description "linear gain.")
        $addarg(@name "q", @default 80, @type "int/float", @description "resonance or slope, depending on @type.")
    ),
    @output $addout(@description "biquad command" @type "llll")
);

## ------------------------------------------------------------

clip = (
    $threshold = 1 -> (
        $threshold = if depth($threshold) > 1 || length($threshold) > 1 then [ bpf($threshold) ] else $threshold;
        [
            [ "fx" "clip" ]
            [ "params" 
                [ "threshold" $threshold ]
            ]
        ]
    )
);

$addref(
    @name "clip",
    @description "Audio process command for applying hard-clip distortion to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "threshold", @type "int/float/llll", @description "distortion amplitude threshold, either as single number or envelope.")
    ),
    @output $addout(@description "clip command" @type "llll")
);

## ------------------------------------------------------------

rubberband = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $envtimeunit = 2,
    $blocksize = 1024,
    $fftwin = 1,
    $phase = 0,
    $pitchmode = 2,
    $formants = 0,
    $smoothing = 0,
    $stretchmode = 0,
    $detector = 0,
    $transients = 2 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        $pitchshift = if depth($pitchshift) > 1 || length($pitchshift) > 1 then [ bpf($pitchshift) ] else $pitchshift;
        [
            [ "fx" "rubberband" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "blocksize" $blocksize ]
                [ "fftwin" $fftwin ]
                [ "phase" $phase ]
                [ "pitchmode" $pitchmode ]
                [ "formants" $formants ]
                [ "smoothing" $smoothing ]
                [ "stretchmode" $stretchmode ]
                [ "detector" $detector ]
                [ "transients" $transients ] 
            ]
        ]
    )
);

$addref(
    @name "rubberband",
    @description "Audio process command for applying rubberband pitch-shifting/time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "pitchshift", @default 0, @type "int/float/llll", @description "pitch shifting amount, as single number or envelope.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            BP_REF_PITCH_FORMAT_OPTIONS
        )
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "blocksize", @default 1024, @type "int", @description "size for granular processes, such as envelopes, in samples.")
        $addarg(@name "fftwin", @default 1, @type "int", @description "FFT window type." @options
            $addopt(@value 0 @description "short") 
            $addopt(@value 1 @description "standard") 
            $addopt(@value 2 @description "long")
        )
        $addarg(@name "phase", @default 0, @type "int", @description "phase adjustment mode." @options
            $addopt(@value 0 @description "elastic") 
            $addopt(@value 1 @description "precise") 
        )
        $addarg(@name "pitchmode", @default 2, @type "int", @description "pitch shift mode." @options
            $addopt(@value 0 @description "high" "speed") 
            $addopt(@value 1 @description "high" "quality") 
            $addopt(@value 2 @description "high" "consistency") 
        )
        $addarg(@name "formants", @default 0, @type "int", @description "formant processing." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "smoothing", @default 0, @type "int", @description "time-domain smoothing." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "stretchmode", @default 0, @type "int", @description "stretch mode." @options 
            $addopt(@value 0 @description "elastic") 
            $addopt(@value 1 @description "precise") 
        )
        $addarg(@name "detector", @default 0, @type "int", @description "transient detection algorithm." @options
            $addopt(@value 0 @description "compound") 
            $addopt(@value 1 @description "percussive") 
            $addopt(@value 2 @description "soft") 
        )
        $addarg(@name "transients", @default 2, @type "int", @description "transient type." @options
            $addopt(@value 0 @description "crisp") 
            $addopt(@value 1 @description "mixed") 
            $addopt(@value 2 @description "smooth") 
        )
    ),
    @output $addout(@description "rubberband command" @type "llll")
);

## ------------------------------------------------------------

soundtouch = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $antialias = 0,
    $quick = 0,
    $speech = 0 -> (
        [
            [ "fx" "soundtouch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "naa" $antialias ]
                [ "quick" $quick ]
                [ "speech" $speech ]
            ]
        ]
    )
);

$addref(
    @name "soundtouch",
    @description "Audio process command for applying soundtouch pitch-shifting/time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float", @description "stretching amount, as a single number.")
        $addarg(@name "pitchshift", @default 0, @type "int/float", @description "pitch shifting amount, as single number.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            BP_REF_PITCH_FORMAT_OPTIONS
        )
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "antialias", @default 0, @type "int", @description "anti-aliasing filter." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "quick", @default 0, @type "int", @description "quick processing. " @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "speech", @default 0, @type "int", @description "tune algorithm for speech. " @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "soundtouch command" @type "llll")
);

## ------------------------------------------------------------

expand = (
    $buffer -> (
        if $buffer.getkey("source") == null then printerror("invalid value for @buffer in expand()");
        $buffer.setkey("offset", 0).setkey("duration", $buffer.getkey("source_end"))
    )
);

$addref(
    @name "expand",
    @description "Modifies offset and duration of a buffer, such that it uses the full length of its reference buffer.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "buffer", @type "llll", @description "buffer to expand.")
    )
    @output $addout(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

groove = (
    $rate = 1,
    $duration = 1000 -> (
        $source = $rate.getkey("source");
        if $source == null then (
            $source = envelope($rate, @duration $duration).getkey("source")
        );
        [
            [ "fx" "groove" ]
            [ "params"
                [ "rate" $source ]
            ]
        ]
    )
);

$addref(
    @name "groove",
    @description "Audio processing command for applying variable-rate sample playback to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "rate" @default 1 @type "int/float/list/llll", @description "playback rate, as either a single number, envelope, or control buffer.")
        $addarg(@name "duration" @default 1000 @type "int/float", @description "duration in milliseconds. Ignored if @rate is a buffer.")
    )
    @output $addout(@description "groove command" @type "llll")
);

## ------------------------------------------------------------

freqshift = (
    $shift,
    $negative = 0 -> (
        if $shift == null then printerror("you must provide a value for @shift in freqshift().");
        $source = $shift.getkey("source");
        if $source != null then (
            $shift = $source
        ) else (
            $shift = [ bpf($shift) ]
        );
        [
            [ "fx" "freqshift" ]
            [ "params"
                [ "negative" float($negative != 0) ]
                [ "shift" $shift ]
            ]
        ]
    )
);

$addref(
    @name "freqshift",
    @description "Audio process command for applying frequency shifting to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "shift", @type "int/float/list/llll", @description "frequency shift in Hertz, as either a single number, an envelope or buffer.")
        $addarg(@name "negative" @default 0 @type "int", @description "Include negative sideband  in output." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "freqshift command" @type "llll")
);

## ------------------------------------------------------------

degrade = (
    $ratio = .5,
    $bits = 4 -> (
        $bits = $bits.getkey("source") ||| [ bpf($bits) ];
        $ratio = $ratio.getkey("source") ||| [ bpf($ratio) ];
        [
            [ "fx" "degrade" ]
            [ "params"
                [ "bits" $bits ]
                [ "ratio" $ratio ]
            ]
        ]
    )
);

$addref(
    @name "degrade",
    @description "Audio process command for reducing sampling rate and bit-depth of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "ratio", @default 0.5, @type "int/float/llll", @description "sampling rate ratio.")
        $addarg(@name "bits", @default 4, @type "int/float/llll", @description "bit depth.")
    ),
    @output $addout(@description "degrade command" @type "llll")
);

## ------------------------------------------------------------

rounding = (
    $value = 1,
    $nearest = 1 -> (
        $value = $value.getkey("source") ||| [ bpf($value) ];
        [
            [ "fx" "round" ]
            [ "params"
                [ "round" 
                    [ "nearest" $nearest ]
                ]
                [ "value" $value ]
            ]
        ]
    )
);

$addref(
    @name "rounding",
    @description "Audio process command for applying signal rounding to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "value", @default 1, @type "int/float/list/llll", @description "rounding value, as either a single number, envelope, or buffer.")
        $addarg(@name "nearest", @default 1, @type "int", @description "rounding behavior" @options
            $addopt(@value 0 @description "floor")
            $addopt(@value 1 @description "nearest")
        )
    ),
    @output $addout(@description "rounding command" @type "llll")
);

## ------------------------------------------------------------

teeth = (
    $feedforward = 5,
    $feedback = 10,
    $gain = 0.5,
    $feedforwardgain = 0.5,
    $feedbackgain = -0.5 -> (
        $feedforward = $feedforward.getkey("source") ||| [ bpf($feedforward) ];
        $feedback = $feedback.getkey("source") ||| [ bpf($feedback) ];
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        $feedforwardgain = $feedforwardgain.getkey("source") ||| [ bpf($feedforwardgain) ];
        $feedbackgain = $feedbackgain.getkey("source") ||| [ bpf($feedbackgain) ];
        [
            [ "fx" "teeth" ]
            [ "params"
                [ "feedforward" $feedforward ]
                [ "feedback" $feedback ]
                [ "gain" $gain ]
                [ "feedforwardgain" $feedforwardgain ]
                [ "feedbackgain" $feedbackgain ]
            ]
        ]
    )
);

$addref(
    @name "teeth",
    @description "Audio process command for applying comb filtering to a buffer, with feedforward and feedback delay control. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "feedforward", @default 5, @type "int/float/llll", @description "feedforward delay time, in milliseconds, as either a single number, envelope, or buffer.")
        $addarg(@name "feedback", @default 10, @type "int/float/llll", @description "feedback delay time, in milliseconds, as either a single number, envelope, or buffer.")
        $addarg(@name "gain", @default 0.5, @type "int/float/llll", @description "linear gain, as either a single number, envelope, or buffer.")
        $addarg(@name "feedforwardgain", @default 0.5, @type "int/float/llll", @description "linear feedforward gain, as either a single number, envelope, or buffer.")
        $addarg(@name "feedbackgain", @default -0.5, @type "int/float/llll", @description "linear feedback gain, as either a single number, envelope, or buffer.")
    ),
    @output $addout(@description "teeth command" @type "llll")
);

## ------------------------------------------------------------

pong = (
    $low = -1,
    $high = 1,
    $mode = 0 -> (
        $low = $low.getkey("source") ||| [ bpf($low) ];
        $high = $high.getkey("source") ||| [ bpf($high) ];
        [
            [ "fx" "pong" ]
            [ "params"
                [ "pong"
                    [ "mode" $mode ]
                ]
                [ "low" $low ]
                [ "high" $high ]
            ]
        ]
    )
);

$addref(
    @name "pong",
    @description "Audio process command for applying range limiting to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "low", @default -1, @type "int/float/llll", @description "low limit value, as either a single number, envelope, or buffer.")
        $addarg(@name "high", @default 1, @type "int/float/llll", @description "high limit value, as either a single number, envelope, or buffer.")
        $addarg(@name "mode", @default 0, @type "int", @description "range limiting mode." @options
            $addopt(@value 0 @description "fold")
            $addopt(@value 1 @description "wrap")
            $addopt(@value 2 @description "clip")
        )
    ),
    @output $addout(@description "pong command" @type "llll")
);

## ------------------------------------------------------------

retune = (
    $pitchgrid = 0,
    $quality = "basic",
    $threshold = 0,
    $ambiencethreshold = 0.3,
    $amount = 100,
    $bypass = 100 -> (
        if $pitchgrid == null then printerror("you must provide a value for @pitchgrid in retune().");
        $pitchgrid = $pitchgrid.thin().fmod(12) * 100;
        $len = $pitchgrid.length();
        if $len <= 2 then (
            $pitchgrid = left($pitchgrid :* (4 - $len), 3) + (0 1 2)
        );
        $pitchgrid = $pitchgrid.sort();
        $notebase = $pitchgrid:1;
        $pitchgrid -= $notebase;
        $pitchgrid = right($pitchgrid, 1);
        $notebase = round($notebase * .01);
        [
            [ "fx" "retune" ]
            [ "params"
                [ "retune" 
                    [ "enablednotes" "all" ]
                    [ "notebase" $notebase ]
                    [ "notelist" $pitchgrid ]
                    [ "correction_ambience_threshold" $ambiencethreshold ]
                    [ "correction_amount" $amount ]
                    [ "correction_bypass" $bypass ]
                    [ "correction_threshold" $threshold ]
                    [ "quality" $quality ]
                ]
            ]
        ]
    )
);

$addref(
    @name "retune",
    @description "Audio process command for applying autotune-like pitch retuning to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "pitchgrid", @default 0, @type "int/float/list", @description "pitch grid to retune to, as a list of pitch classes.")
        $addarg(@name "threshold" @default 0 @type "int/float" @description "correction threshold.")
        $addarg(@name "ambiencethreshold" @default 0.3 @type "int/float" @description "correction ambience threshold, between -10 and 10.")
        $addarg(@name "amount" @default 100 @type "int/float" @description "pitch correction amount.")
        $addarg(@name "bypass" @default 100 @type "int/float" @description "pitch correction auto-bypass threshold, at which signal passes unaffected.")
        $addarg(@name "quality" @default "'basic'" @type "symbol" @description "pitch correction quality." @options
            $addopt(@value "'basic'")
            $addopt(@value "'good'")
            $addopt(@value "'better'")
            $addopt(@value "'best'")
        )
    ),
    @output $addout(@description "retune command" @type "llll")
);

## ------------------------------------------------------------

waveshape = (
    $phase = 0 1,
    $duration = 1000 -> (
        $source = $phase.getkey("source");
        if $source == null then (
            $source = envelope($phase, @duration $duration).getkey("source")
        );
        [
            [ "fx" "waveshape" ]
            [ "params"
                [ "phase" $source ]
            ]
        ]
    )
);

$addref(
    @name "waveshape",
    @description "Audio process command for waveshaping a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "phase", @default -1 1, @type "int/float", @description "buffer phase envelope between -1 and 1, either as an envelope or a buffer.")
        $addarg(@name "duration", @default 1000, @type "int", @description "envelope duration in milliseconds. Ignored if @phase is a buffer.")
    ),
    @output $addout(@description "waveshape command" @type "llll")
);

## ------------------------------------------------------------

scrub = (
    $phase = 0 1,
    $duration = 1000 -> (
        $source = $phase.getkey("source");
        if $source == null then (
            $source = envelope($phase, @duration $duration).getkey("source")
        );
        [
            [ "fx" "scrub" ]
            [ "params"
                [ "phase" $source ]
            ]
        ]
    )
);

$addref(
    @name "scrub",
    @description "Audio process command for scrubbing through a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "phase", @default 0 1, @type "int/float", @description "buffer phase envelope between 0 and 1, either as an envelope or a buffer.")
        $addarg(@name "duration", @default 1000, @type "int", @description "envelope duration in milliseconds. Ignored if @phase is a buffer.")
    ),
    @output $addout(@description "scrub command" @type "llll")
);

## ------------------------------------------------------------

repeat = (
    $duration = 2,
    $timeunit = 2 -> (
        [
            [ "fx" "repeat" ]
            [ "params"
                [ "duration" max(1, $duration) ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "repeat",
    @description "Audio process command for repeating a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "duration", @default 2, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "repeat command" @type "llll")
);

## ------------------------------------------------------------

scaling = (
    $inmin = 0,
    $inmax = 1,
    $outmin = 0,
    $outmax = 1 -> (
        [
            [ "fx" "scale" ]
            [ "params"
                [ "inmin" $inmin ]
                [ "inmax" $inmax ]
                [ "outmin" $outmin ]
                [ "outmax" $outmax ]
            ]
        ]
    )
);

$addref(
    @name "scaling",
    @description "Audio process command for applying amplitude scaling to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "inmin", @default 0, @type "int/float", @description "input minimum value.")
        $addarg(@name "inmax", @default 1, @type "int/float", @description "input maximum value.")
        $addarg(@name "outmin", @default 0, @type "int/float", @description "output minimum value.")
        $addarg(@name "outmax", @default 1, @type "int/float", @description "output maximum value.")
    ),
    @output $addout(@description "scaling command" @type "llll")
);

## ------------------------------------------------------------

mix = (
    $buffers = null,
    $gains = null,
    $offsets = null,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $resamplingpolicy = 3,
    $ampunit = 0,
    $envampunit = 0,
    $timeunit = 0,
    $envtimeunit = 2,
    $interp = 0,
    $normalize = 0 -> (
        if $buffers == null then printerror("you must provide a values for @buffers in mix()");
        $numbuffers = length($buffers) + 1;
        $buffers = for $buffer in $buffers collect $buffer.process(bpthru()).getkey("source");
        [
            [ "fx" "mix" ]
            [ "params"
                [ "buffers" $buffers ]
                [ "gains" right(1 $gains, -$numbuffers) ]
                [ "offsets" right(0 $offsets, -$numbuffers) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "interp" $interp ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

$addref(
    @name "mix",
    @description "Audio process command for mixing multiple buffers. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "buffers", @type "list/llll", @description "list of buffers to mix.")
        $addarg(@name "gains", @default "null" @type "list/llll/null", @description "gain values for each buffer to mix, as either a single number or envelope.")
        $addarg(@name "offsets", @default "null", @type "list/null", @description "time offset values for each buffer to mix.")
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
        $addarg(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
            BP_REF_RESAMPLINGPOLICY_OPTIONS
        )
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envampunit", @default 0, @type "int", @description "envelope amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "interp", @default 0, @type "int", @description "band-limited interpolation via resampling for non-integer offsets." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "normalize", @default 0, @type "int", @description "normalization." @options 
            BP_REF_NORMALIZE_OPTIONS
        )
    ),
    @output $addout(@description "mix command" @type "llll")
);

## ------------------------------------------------------------

BP_BUFFER_ARITHMETIC_FUNC = (
    $name,
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        ## raise error if @operand is null
        if $operand == null then printerror("you must provide a value for @operand in " + $name + "().");

        ## check if @operand is buffer, envelope or scalar.
        $depth = depth($operand);
        $length = length($operand);
        if $depth > 1 || $length > 1 then (
            $source = $operand.getkey("source");
            ## if buffer, assign file to @operand
            if $source != null then (
                $operand = $source
            ) else (
                ## if envelope, clean format and wrap if envelope
                $operand = [ bpf($operand) ]
            )
        );
        [
            [ "fx" "arithmetic" ]
            [ "params"
                [ "operator" $name ]
                [ "operand" left($operand, 1) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

BP_BUFFER_ARITHMETIC_ARGS = (
    $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    $addarg(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
        BP_REF_RESAMPLINGMODE_OPTIONS
    )
    $addarg(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
        BP_REF_RESAMPLINGPOLICY_OPTIONS
    )
    $addarg(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
        BP_REF_TIMEUNIT_OPTIONS
    )
);

## ------------------------------------------------------------

absolute = (
    -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "abs"
            @operand 0
        )
    )
);

$addref(
    @name "absolute",
    @description "Audio process command for computing the absolute value of a buffer signal. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output $addout(@description "absolute command" @type "llll")
);

## ------------------------------------------------------------

squareroot = (
    -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "sqrt"
            @operand 0
        )
    )
);

$addref(
    @name "squareroot",
    @description "Audio process command for computing the square root of a buffer signal. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output $addout(@description "squareroot command" @type "llll")
);

## ------------------------------------------------------------

power = (
    $operand = 2,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "pow"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "power",
    @description "Audio process command for performing exponentiation on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "operand", @default 2 @type "int/float/llll", @description "value to raise buffer signal to, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "power command" @type "llll")
);

## ------------------------------------------------------------

plus = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "plus"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "plus",
    @description "Audio process command for performing addition on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to add to buffer, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "plus command" @type "llll")
);

## ------------------------------------------------------------

minus = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "minus"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "minus",
    @description "Audio process command for performing subtraction on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to subtract from buffer, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "minus command" @type "llll")
);

## ------------------------------------------------------------

multiply = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "times"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "multiply",
    @description "Audio process command for performing multiplication on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to multiply buffer by either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "multiply command" @type "llll")
);

## ------------------------------------------------------------

divide = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_BUFFER_ARITHMETIC_FUNC(
            @name "div"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "divide",
    @description "Audio process command for performing division on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to divide buffer by either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "divide command" @type "llll")
);

## ------------------------------------------------------------

wavesetrepeat = (
    $times = 2,
    $span = 1,
    $normalize = 0 -> (
        [
            [ "fx" "wavesetrepeat" ]
            [ "params"
                [ "times" max(1, $times) ]
                [ "span" $span ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

$addref(
    @name "wavesetrepeat",
    @description "Audio process command for applying waveset repetition to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "times",  @default 2, @type "int", @description "number of repetitions.")
        $addarg(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
        $addarg(@name "normalize", @default 0, @type "int", @description "waveset normalization." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "waveset repeat command" @type "llll")
);

## ------------------------------------------------------------

wavesetshuffle = (
    $maxdist = 1,
    $span = 1 -> (
        [
            [ "fx" "wavesetshuffle" ]
            [ "params"
                [ "maxdist" $maxdist ]
                [ "span" $span ]
            ]
        ]
    )
);

$addref(
    @name "wavesetshuffle",
    @description "Audio process command for applying waveset shuffling to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "maxdist", @default 1, @type "int", @description "maximum shuffling distance.")
        $addarg(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
    ),
    @output $addout(@description "waveset shuffle command" @type "llll")
);

## ------------------------------------------------------------

rampsmooth = (
    $up = 1024,
    $down = 1024 -> (
        $up = $up.getkey("source") ||| [ bpf($up) ];
        $down = $down.getkey("source") ||| [ bpf($down) ];
        [
            [ "fx" "rampsmooth" ]
            [ "params"
                [ "up" $up ]
                [ "down" $down ]
            ]
        ]
    )
);

$addref(
    @name "rampsmooth",
    @description "Audio process command for applying rampsmoothing to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "up", @default 1024, @type "int/list/llll", @description "ramp up, in samples, as either a single number, envelope, or buffer.")
        $addarg(@name "down", @default 1024, @type "int/list/llll", @description "ramp down, in samples, as either a single number, envelope, or buffer.")
    ),
    @output $addout(@description "rampsmooth command" @type "llll")
);

## ------------------------------------------------------------

onepole = (
    $cutoff,
    $highpass = 0 -> (
        if $cutoff == null then (
            printerror("you must provide @cutoff value in onepole()")
        );
        [
            [ "fx" "onepole" ]
            [ "params"
                [ "cutoff" $cutoff ]
                [ "highpass" $highpass ]
            ]
        ]
    )
);

$addref(
    @name "onepole",
    @description "Audio process command for applying single-pole lowpass or highpass filtering to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "cutoff", @default 1, @type "int/float", @description "cutoff frequency.")
        $addarg(@name "highpass", @default 0, @type "int", @description "highpass filter mode." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "onepole command" @type "llll")
);

## ------------------------------------------------------------

mixdown = (
    $numchannels = 1,
    $channelmode = 3,
    $autogain = 0 -> (
        [
            [ "fx" "mixdown" ]
            [ "params"
                [ "numchannels" $numchannels ]
                [ "channelmode" $channelmode ]
                [ "autogain" $autogain ]
            ]
        ]
    )
);

$addref(
    @name "mixdown",
    @description "Audio process command for mixing down (or up) the number of channels of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "numchannels", @default 1, @type "int", @description "number of output channels.")
        $addarg(@name "channelmode", @default 3, @type "int", @description "downmixing channel conversion type." @options 
            $addopt(@value 0, @description "delete" "all" "samples")
            $addopt(@value 1, @description "only" "keep" "existing channels")
            $addopt(@value 2, @description "pad" "last" "channel")
            $addopt(@value 3, @description "cyclic" "repetition" "of" "channels" "while" "upmixing.")
            $addopt(@value 4, @description "palindrome" "cycling" "of" "channels" "while" "upmixing.")
            $addopt(@value 5, @description "pan" "channels" "to" "new" "configuration")
        )
        $addarg(@name "autogain", @default 0, @type "int", @description "apply audio compensation, based on ratio between input and output channels." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "onepole command" @type "llll")
);

## ------------------------------------------------------------

join = (
    $buffers,
    $xfade = 0,
    $xfadecurve = 0,
    $xfadetype = 1,
    $fadeboundaries = 0,
    $timeunit = 0,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $resamplingpolicy = 3 -> (
        $buffers = for $buffer in $buffers collect (
            $source = $buffer.getkey("source");
            if $source == null then (
                printerror("invalid buffer in join():" $buffer) 
            ) else (
                $buffer.process(bpthru()).getkey("source")
            )
        );
        [
            [ "fx" "join" ]
            [ "params"
                [ "buffers" $buffers ]
                [ "timeunit" $timeunit ]
                [ "xfadecurve" $xfadecurve ]
                [ "xfade" $xfade ]
                [ "xfadetype" $xfadetype + 1 ]
                [ "fadeboundaries" $fadeboundaries ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
            ]
        ]
    )
);

$addref(
    @name "join",
    @description "Audio process command for concatenating one or more buffers to the processed buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "buffers", @type "llll", @description "buffers to concatenate.")
        $addarg(@name "xfade", @default 0, @type "int/float", @description "duration of the crossfade, in samples.")
        $addarg(@name "xfadecurve", @default 0, @type "int/float", @description "curve parameter for the crossfade.")
        $addarg(@name "xfadetype", @default 1, @type "int", @description "cross fade type." @options 
            BP_REF_CURVE_OPTIONS
        )
        $addarg(@name "fadeboundaries", @default 0, @type "int", @description "fade beginning of first buffer and end of last buffer." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
        $addarg(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
            BP_REF_RESAMPLINGPOLICY_OPTIONS
        )
    ),
    @output $addout(@description "join command" @type "llll")
);

## ------------------------------------------------------------

trim = (
    $threshold = 0.1,
    $ampunit = 0,
    $start = 1,
    $end = 1 -> (
        [
            [ "fx" "trim" ]
            [ "params"
                [ "ampunit" $ampunit ]
                [ "start" $start ]
                [ "end" $end ]
                [ "thresh" $threshold ]
            ]
        ]
    )
);

$addref(
    @name "trim",
    @description "Audio process command for applying silence-based trimming to a buffer. When the entire buffer is considered silent, the resulting buffer's duration will be a single audio sample. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "threshold" @default 0.1 @type "int/float", @description "amplitude threshold at/below which samples are considered silence.")
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit for @threshold." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "start" @default 1 @type "int/float", @description "trim the beginning of the buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "end" @default 1 @type "int/float", @description "trim the end of the buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "join command" @type "llll")
);

## ------------------------------------------------------------

timesquash = (
    $duration = 1,
    $timeunit = 2, 
    $timeblock = 4096,
    $mode = 1,
    $xfade = 4096,
    $xfadecurve = 0,
    $xfadetype = 1,
    $glbleed = 4,
    $glnumiter = 10,
    $glrandomize = 0,
    $glrect = 1,
    $batchsize = 1,
    $batchinterrupt = 0,
    $energy = 2,
    $forwardenergy = 1.,
    $forwardenergyembed = 1,
    $forwardenergytype = 1,
    $framesize = 2048,
    $hopsize = 1024,
    $phasehandling = 2,
    $regularization = 0.01,
    $wintype = "sqrthann" "sqrthann" -> (
        [
            [ "fx" "timesquash" ]
            [ "params"
                [ "duration" $duration ]
                [ "mode" $mode ]
                [ "timeblock" $timeblock ]
                [ "xfade" $xfade ]
                [ "xfadecurve" $xfadecurve ]
                [ "xfadetype" $xfadetype + 1 ]
                [ "glbleed" $glbleed ]
                [ "glnumiter" $glnumiter ]
                [ "glrandomize" $glrandomize ]
                [ "glrect" $glrect ]
                [ "batchsize" $batchsize ]
                [ "energy" $energy ]
                [ "forwardenergy" $forwardenergy ]
                [ "forwardenergyembed" $forwardenergyembed ]
                [ "forwardenergytype" $forwardenergytype ]
                [ "batchinterrupt" $batchinterrupt ]
                [ "phasehandling" $phasehandling ]
                [ "regularization" $regularization ]
                [ "hopsize" $hopsize ]
                [ "framesize" $framesize ]
                [ "wintype" $wintype ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "timesquash",
    @description "Audio process command for applying timesquash time compression to a buffer. This removes time from a sample by shifting portions of the spectrogram while preserving the relevant content. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration."
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "timeblock", @default 4096, @type "int", @description "duration of each time block to be removed.")
        $addarg(@name "mode", @default 1, @type "int", @description "working mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "xfade", @default 4096, @type "int/float", @description "duration of the crossfade, in samples.")
        $addarg(@name "xfadecurve", @default 0, @type "int/float", @description "curve parameter for the crossfade.")
        $addarg(@name "xfadetype", @default 1, @type "int", @description "cross fade type." @options 
            BP_REF_CURVE_OPTIONS
        )
        $addarg(@name "glbleed", @default 4, @type "int", @description "number of frames of invalidation for the Griffin-Lim algorithm, when @phasehandling is 2.")
        $addarg(@name "glnumiter", @default 10, @type "int", @description "number of Griffin-Lim iterations, when @phasehandling is 2.")
        $addarg(@name "glrandomize", @default 0, @type "int", @description "randomize the phases of the regions subject to the Griffin-Lim algorithm, when @phasehandling is 2." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "glrect", @default 1, @type "int", @description "invalidate whole rectangular regions whose phases are recomputed via the Griffin-Lim algorithm, when @phasehandling is 2." @options 
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "batchsize", @default 1, @type "int", @description "number of seams processed in batch.")
        $addarg(@name "batchinterrupt", @default 0, @type "int", @description "interrupt batch when crossing.")
        $addarg(@name "energy", @default 2, @type "int", @description "energy function used for computing seams." @options
            $addopt(@value 0, @description "magnitude")
            $addopt(@value 1, @description "gradient" "magnitude")
            $addopt(@value 2, @description "Sobel")
        )
        $addarg(@name "forwardenergy", @default 1, @type "int/float", @description "amount of forward energy contribution.")
        $addarg(@name "forwardenergyembed", @default 1, @type "int", @description "embed forward energy in cumulative matrix." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "forwardenergytype", @default 1, @type "int", @description "forward energy type." @options
            $addopt(@value 0, @description "gradient" "L1" "norm")
            $addopt(@value 1, @description "energy" "L2" "norm")
        )
        $addarg(@name "framesize", @default 2048, @type "int", @description "window size, in samples")
        $addarg(@name "hopsize", @default 1024, @type "int", @description "hop size, in samples")
        $addarg(@name "phasehandling", @default 2, @type "int", @description "phase handling mode." @options
            $addopt(@value 0, @description "keep")
            $addopt(@value 1, @description "compensate")
            $addopt(@value 2, @description "Griffin-Lim")
        )
        $addarg(@name "regularization", @default 0.01, @type "int/float", @description "how much energy of a bin smears on the ones above and below, between 0 and 1.")
        $addarg(@name "wintype", @default "'sqrthann'" "'sqrthann'", @type "list/symbol", @description "window type." @options BP_REF_WINDOW_OPTIONS)
    ),
    @output $addout(@description "timesquash command" @type "llll")
);

## ------------------------------------------------------------

resample = (
    $duration = 1,
    $timeunit = 2,
    $changesr = 0,
    $antimeunit = 1,
    $resamplingmode = "sinc",
    $resamplingfiltersize = 11 -> (
        if length($duration) > 1 || depth($duration) > 1 then ($duration = [ bpf($duration) ]);
        [
            [ "fx" "resample" ]
            [ "params"
                [ "duration" $duration ]
                [ "timeunit" $timeunit ]
                [ "changesr" $changesr ]
                [ "antimeunit" $antimeunit ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
            ]
        ]
    )
);

$addref(
    @name "resample",
    @description "Audio process command for applying stretching/pitch shifting a buffer via resampling. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "changesr", @default 0, @type "int", @description "change sampling rate." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "antimeunit", @default 1, @type "int", @description "time unit for analysis." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    ),
    @output $addout(@description "resample command" @type "llll")
);

## ------------------------------------------------------------

panning = (
    $position = 0.5,
    $numchannels = 2,
    $panmode = 0,
    $panlaw = 1,
    $rangetype = 1,
    $range = 0. 1.,
    $compensate = 1,
    $spread = 1,    
    $envtimeunit = 2 -> (
        $source = $position.getkey("source");
        if $source != null then (
            $position = $source
        ) else if length($position) > 1 || depth($position) > 1 then (
            $position = [ bpf($position) ]
        );
        [
            [ "fx" "panning" ]
            [ "params"
                [ "position" $position ]
                [ "numchannels" $numchannels ]
                [ "panlaw" $panlaw ]
                [ "panmode" $panmode ]
                [ "rangetype" $rangetype ]
                [ "range" $range ]
                [ "compensate" $compensate ]
                [ "envtimeunit" $envtimeunit ]
                [ "spread" $spread ]
            ]
        ]
    )
);

$addref(
    @name "panning",
    @description "Audio process command for applying 1-D panning to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "position" @type "int/float/list/llll", @description "panning position, as either a single number, envelope, or buffer.")
        $addarg(@name "numchannels", @default 2, @type "int", @description "number of output channels.")
        $addarg(@name "panmode", @type "int", @default 0, @description "panning mode." @options 
            $addopt(@value 0, @description "linear")
            $addopt(@value 1, @description "circular")
        )
        $addarg(@name "panlaw", @default 1, @type "int", @description "panning law." @options 
            $addopt(@value 0 @description "nearest" "neighbor")
            $addopt(@value 1 @description "cosine")
        )
        $addarg(@name "rangetype", @default 1, @type "int", @description "panning range type." @options
            $addopt(@value 0 @description "custom")
            $addopt(@value 1 @description "0" "to" "1")
            $addopt(@value 2 @description "-1" "to" "1")
            $addopt(@value 3 @description "loudspeaker" "number" "—" "0-based")
            $addopt(@value 4 @description "loudspeaker" "number" "—" "1-based")
        )
        $addarg(@name "range", @default 0 1, @type "list", @description "panning range, as a <min> <max> value pair. Ignored unless @rangetype is 0")
        $addarg(@name "compensate", @default 1, @type "int", @description "Reduce gain for multichannel files by a factor of the number of channels." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "spread", @type "int/float", @default 1, @description "multichannel panning spread, between 0 and 1.")
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "normalize command" @type "llll")
);

## ------------------------------------------------------------

normalize = (
    $level = -6,
    $mix = 1,
    $rms = 0,
    $ampunit = 1 -> (
        [
            [ "fx" "normalize" ]
            [ "params"
                [ "ampunit" $ampunit ]
                [ "rms" $rms ]
                [ "level" $level ]
                [ "mix" $mix ]
            ]
        ]
    )
);

$addref(
    @name "normalize",
    @description "Audio process command for normalizing the amplitude of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "level", @default -6, @type "int/float", @description "reference level.")
        $addarg(@name "mix", @default 1, @type "int", @description "dry/wet mix, between 0 and 1.")
        $addarg(@name "rms", @default 0, @type "int", @description "use root mean square." @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "ampunit", @default 1, @type "int", @description "amplitude unit for @level." @options
            BP_REF_AMPUNIT_OPTIONS
        )
    ),
    @output $addout(@description "normalize command" @type "llll")
);

## ------------------------------------------------------------

gain = (
    $gain,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $ampunit = 0,
    $envampunit = 0,
    $envtimeunit = 2 -> (
        if $gain == null then (
            printerror("you must provide a @gain value in gain().")
        );
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        [
            [ "fx" "gain" ]
            [ "params"
                [ "gain" $gain ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

$addref(
    @name "gain",
    @description "Audio process command for modifying a buffer's gain. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "gain", @type "int/float/llll", @description "gain amount, as either a single number or envelope.")
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size, in samples.")
        $addarg(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envampunit", @default 0, @type "int", @description "amplitude unit for @gain envelope." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "gain command" @type "llll")
);

## ------------------------------------------------------------

dynamics = (
    $attack = 10,
    $release = 50,
    $knee = 0.7,
    $makeup = 0,
    $ratio = 1.5,
    $thresh = -20.,
    $ampunit = 1,
    $timeunit = 0 -> (
        [
            [ "fx" "dynamics" ]
            [ "params"
                [ "attack" $attack ]
                [ "release" $release ]
                [ "knee" $knee ]
                [ "makeup" $makeup ]
                [ "ratio" $ratio ]
                [ "thresh" $thresh ]
                [ "ampunit" $ampunit ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "dynamics",
    @description "Audio process command for applying simple compression to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        $addarg(@name "attack", @default 10, @type "int/float", @description "attack time.")
        $addarg(@name "release", @default 50, @type "int/float", @description "release time.")
        $addarg(@name "knee", @default 0.7, @type "int/float", @description "knee width.")
        $addarg(@name "makeup", @default 0, @type "int/float", @description "make-up gain.")
        $addarg(@name "ratio", @default 1.5, @type "int/float", @description "compression ratio.")
        $addarg(@name "thresh", @default -20, @type "int/float", @description "amplitude threshold.")
        $addarg(@name "ampunit", @default 1, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "dynamics command" @type "llll")
);

## ------------------------------------------------------------

topartialtracks = (
    $buffer,
    $winstartfromzero = 0,
    $framesize = 2048,
    $hopsize = 512,
    $freqdevoffset = 20,
    $freqdevslope = 0.01,
    $magnitudethreshold = 0.0002,
    $maxfrequency = 22050,
    $minfrequency = 0,
    $maxpeaks = 100,
    $maxnsines = 100,
    $numframes = 'auto',
    $orderby = 'frequency',
    $overlap = 4,
    $wintype = 'hann',
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0,
    $timeunit = 0,
    $downmix = 1 -> (
        $buffer ||| printerror("you must provide a value for @buffer in topartialtracks().");
        if $buffer.getkey("source") === null then printerror($buffer "is not a buffer in topartialtracks().");
        $source = $buffer.process(bpthru()).getkey("source");
        BP_DISPATCH_FUNC("resynth", 
            [ "analysis" 
                [ "winstartfromzero" $winstartfromzero ]
                [ "framesize" $framesize ]
                [ "freqdevoffset" $freqdevoffset ]
                [ "freqdevslope" $freqdevslope ]
                [ "hopsize" $hopsize ]
                [ "magnitudethreshold" $magnitudethreshold ]
                [ "maxfrequency" $maxfrequency ]
                [ "maxpeaks" $maxpeaks ]
                [ "maxnsines" $maxnsines ]
                [ "minfrequency" $minfrequency ]
                [ "numframes" $numframes ]
                [ "orderby" $orderby ]
                [ "overlap" $overlap ]
                [ "wintype" $wintype ]
                [ "ampunit" $ampunit ]
                [ "antimeunit" $antimeunit ]
                [ "angleunit" $angleunit ]
                [ "frequnit" $frequnit ]
                [ "timeunit" $timeunit ]
                [ "downmix" $downmix ]
                $source 
            ]
        );
        [ BP_RESYNTH_ANALYSIS ]
    )
);

$addref(
    @name "topartialtracks",
    @description "Converts a buffer into a partial track analysis.",
    @category BP_REF_LABEL_ANALYSIS,
    @arguments (
        $addarg(@name "buffer" @type "llll" @description "buffer to analyze.")
        $addarg(@name "winstartfromzero", @default 0, @type "int", @description "first window starts at zero" @options
            BP_REF_SWITCH_OPTIONS
        )
        $addarg(@name "framesize", @default 2048, @type "int", @description "window size, in samples.")
        $addarg(@name "hopsize", @default 512, @type "int", @description "hop size, in samples.")
        $addarg(@name "freqdevoffset" @default 20 @type "int" @description "frequency deviation offset.")
        $addarg(@name "freqdevslope" @default 0.01 @type "int/float" @description "frequency deviation slope.")
        $addarg(@name "magnitudethreshold", @default 2e-4, @type "float", @description "peak amplitude threshold.")
        $addarg(@name "maxfrequency", @default 22050, @type "int/float", @description "max. frequency of the range to evaluate.")
        $addarg(@name "minfrequency", @default 0, @type "int/float", @description "min. frequency of the range to evaluate.")
        $addarg(@name "maxpeaks", @default 100, @type "int", @description "max. number of returned peaks.")
        $addarg(@name "maxnsines", @default 100, @type "int", @description "max. number of sines per frame.")
        $addarg(@name "numframes" @default "'auto'" @type "int/symbol" @description "number of frames.")
        $addarg(@name "orderby" @default "'frequency'" @type "symbol" @description "ordering feature." @options 
            $addopt(@value "'frequency'")
            $addopt(@value "'magnitude'")
        )
        $addarg(@name "overlap" @default 4 @type "int" @description "overlap.")
        $addarg(@name "wintype", @default "'hann'", @type "symbol", @description "window type." @options 
            BP_REF_WINDOW_OPTIONS
        )
        $addarg(@name "ampunit" @default 0 @type "int" @description "amplitude unit." @options 
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "antimeunit" @default 1 @type "int" @description "analysis time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "angleunit" @default 0 @type "int" @description "angle unit." @options 
            $addopt(@value 0 @description "'radians'")
            $addopt(@value 1 @description "'degrees'")
            $addopt(@value 2 @description "'turns'")
        )
        $addarg(@name "frequnit", @default 0, @type "int", @description "unit for frequency components in @func." @options 
            BP_REF_FREQUNIT_OPTIONS
        )
        $addarg(@name "timeunit" @default 0 @type "int" @description "time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "downmix" @default 1 @type "int" @description "downmix buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        ## $addarg(@name "stochastic", @default 0, @type "int", @description "analysis/resynthesis mode." @options
        ##     $addopt(@value 0 @description "sinusoidal")
        ##     $addopt(@value 1 @description "stochastic" "+" "sinusoidal")
        ## )
        ## $addarg(@name "stocf", @default 0.2, @type "int/float", @description "decimation factor of stochastic approximation. Ignored if @stochastic is 0.")
    ),
    @output $addout(@description "partial track analysis" @type "llll")
);

## ------------------------------------------------------------

frompartialtracks = (
    $frequencies,
    $magnitudes,
    $phases,
    $framesize = 2048,
    $hopsize = 512,
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0 -> (
        if $frequencies == null then printerror("@frequencies cannot be null in frompartialtracks().");
        if $magnitudes == null then printerror("@magnitudes cannot be null in frompartialtracks().");
        if $phases == null then printerror("@phases cannot be null in frompartialtracks().");
        BP_DISPATCH_FUNC("resynth", 
            [ "synthesis" 
                [ "params"
                    [ "framesize" $framesize ]
                    [ "hopsize" $hopsize ]
                    [ "ampunit" $ampunit ]
                    [ "antimeunit" $antimeunit ]
                    [ "angleunit" $angleunit ]
                    [ "frequnit" $frequnit ]
                ]
                [ "phases" $phases ]
                [ "magnitudes" $magnitudes ]
                [ "frequencies" $frequencies ]
            ]
        );
        BP_NEWBUFF_FUNC(@source BP_RESYNTH_SYNTHESIS)
    )
);

$addref(
    @name "frompartialtracks",
    @description "Converts a partial track analysis into a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        $addarg(@name "frequencies" @type "llll")
        $addarg(@name "magnitudes" @type "llll")
        $addarg(@name "phases" @type "llll")
        $addarg(@name "framesize" @default 2048 @type "int")
        $addarg(@name "hopsize" @default 512 @type "int")
        $addarg(@name "ampunit" @default 0 @type "int" @description "amplitude unit." @options 
            BP_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "antimeunit" @default 1 @type "int" @description "analysis time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "angleunit" @default 0 @type "int" @description "angle unit." @options 
            $addopt(@value 0 @description "'radians'")
            $addopt(@value 1 @description "'degrees'")
            $addopt(@value 2 @description "'turns'")
        )
        $addarg(@name "frequnit", @default 0, @type "int", @description "unit for frequency components in @func." @options 
            BP_REF_FREQUNIT_OPTIONS
        )
    ),
    @output $addout(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

buildtree = (
    $buffers, $keys -> (
        if $keys == null then (
            printerror("you must provide a one or more features to the @keys argument in buildtree()")
        );
        BP_DISPATCH_FUNC("kdtree", [ "features" $keys] ["buffers" $buffers])
    )
);

$addref(
    @name "buildtree",
    @description "Builds a k-dimensional tree on a set of buffers, given one or more buffer features. This tree can be queried via the #searchtree function. Note that there can only be one tree at a time.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "buffers", @type "llll", @description "list of buffers.")
        $addarg(@name "keys" @type "list/symbol", @description "one or more features to build tree on, as a list of symbols.")
    )
);

## ------------------------------------------------------------

searchtree = (
    $target -> (
        BP_DISPATCH_FUNC("kdtree", [ "query" $target]);
        BP_TREE_RESULT
    )
);

$addref(
    @name "searchtree",
    @description "k-nearest neighbor search on the current k-dimensional tree. The search input can be either a single buffer or, more directly, the values associated with the features the tree was based on. See #buildtree.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        $addarg(@name "target", @type "llll", @description "target buffer or feature value to find nearest neighbor for.")
    ),
    @output $addout(@description "nearest buffer" @type "llll")
);

## ------------------------------------------------------------

null